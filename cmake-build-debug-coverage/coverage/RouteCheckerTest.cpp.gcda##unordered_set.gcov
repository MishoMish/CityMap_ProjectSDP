        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX13.3.sdk/usr/include/c++/v1/unordered_set
        -:    0:Graph:/Users/mihaildobroslavski/CLionProjects/CityMapProject/cmake-build-debug-coverage/CMakeFiles/RouteCheckerTest.dir/UnitTesting/RouteCheckerTest.cpp.gcno
        -:    0:Data:/Users/mihaildobroslavski/CLionProjects/CityMapProject/cmake-build-debug-coverage/CMakeFiles/RouteCheckerTest.dir/UnitTesting/RouteCheckerTest.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_UNORDERED_SET
        -:   11:#define _LIBCPP_UNORDERED_SET
        -:   12:
        -:   13:/*
        -:   14:
        -:   15:    unordered_set synopsis
        -:   16:
        -:   17:#include <initializer_list>
        -:   18:
        -:   19:namespace std
        -:   20:{
        -:   21:
        -:   22:template <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,
        -:   23:          class Alloc = allocator<Value>>
        -:   24:class unordered_set
        -:   25:{
        -:   26:public:
        -:   27:    // types
        -:   28:    typedef Value                                                      key_type;
        -:   29:    typedef key_type                                                   value_type;
        -:   30:    typedef Hash                                                       hasher;
        -:   31:    typedef Pred                                                       key_equal;
        -:   32:    typedef Alloc                                                      allocator_type;
        -:   33:    typedef value_type&                                                reference;
        -:   34:    typedef const value_type&                                          const_reference;
        -:   35:    typedef typename allocator_traits<allocator_type>::pointer         pointer;
        -:   36:    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
        -:   37:    typedef typename allocator_traits<allocator_type>::size_type       size_type;
        -:   38:    typedef typename allocator_traits<allocator_type>::difference_type difference_type;
        -:   39:
        -:   40:    typedef /unspecified/ iterator;
        -:   41:    typedef /unspecified/ const_iterator;
        -:   42:    typedef /unspecified/ local_iterator;
        -:   43:    typedef /unspecified/ const_local_iterator;
        -:   44:
        -:   45:    typedef unspecified node_type unspecified;                            // C++17
        -:   46:    typedef INSERT_RETURN_TYPE<iterator, node_type> insert_return_type;   // C++17
        -:   47:
        -:   48:    unordered_set()
        -:   49:        noexcept(
        -:   50:            is_nothrow_default_constructible<hasher>::value &&
        -:   51:            is_nothrow_default_constructible<key_equal>::value &&
        -:   52:            is_nothrow_default_constructible<allocator_type>::value);
        -:   53:    explicit unordered_set(size_type n, const hasher& hf = hasher(),
        -:   54:                           const key_equal& eql = key_equal(),
        -:   55:                           const allocator_type& a = allocator_type());
        -:   56:    template <class InputIterator>
        -:   57:        unordered_set(InputIterator f, InputIterator l,
        -:   58:                      size_type n = 0, const hasher& hf = hasher(),
        -:   59:                      const key_equal& eql = key_equal(),
        -:   60:                      const allocator_type& a = allocator_type());
        -:   61:    explicit unordered_set(const allocator_type&);
        -:   62:    unordered_set(const unordered_set&);
        -:   63:    unordered_set(const unordered_set&, const Allocator&);
        -:   64:    unordered_set(unordered_set&&)
        -:   65:        noexcept(
        -:   66:            is_nothrow_move_constructible<hasher>::value &&
        -:   67:            is_nothrow_move_constructible<key_equal>::value &&
        -:   68:            is_nothrow_move_constructible<allocator_type>::value);
        -:   69:    unordered_set(unordered_set&&, const Allocator&);
        -:   70:    unordered_set(initializer_list<value_type>, size_type n = 0,
        -:   71:                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:   72:                  const allocator_type& a = allocator_type());
        -:   73:    unordered_set(size_type n, const allocator_type& a); // C++14
        -:   74:    unordered_set(size_type n, const hasher& hf, const allocator_type& a); // C++14
        -:   75:    template <class InputIterator>
        -:   76:      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14
        -:   77:    template <class InputIterator>
        -:   78:      unordered_set(InputIterator f, InputIterator l, size_type n,
        -:   79:                    const hasher& hf,  const allocator_type& a); // C++14
        -:   80:    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14
        -:   81:    unordered_set(initializer_list<value_type> il, size_type n,
        -:   82:                  const hasher& hf,  const allocator_type& a); // C++14
        -:   83:    ~unordered_set();
        -:   84:    unordered_set& operator=(const unordered_set&);
        -:   85:    unordered_set& operator=(unordered_set&&)
        -:   86:        noexcept(
        -:   87:            allocator_type::propagate_on_container_move_assignment::value &&
        -:   88:            is_nothrow_move_assignable<allocator_type>::value &&
        -:   89:            is_nothrow_move_assignable<hasher>::value &&
        -:   90:            is_nothrow_move_assignable<key_equal>::value);
        -:   91:    unordered_set& operator=(initializer_list<value_type>);
        -:   92:
        -:   93:    allocator_type get_allocator() const noexcept;
        -:   94:
        -:   95:    bool      empty() const noexcept;
        -:   96:    size_type size() const noexcept;
        -:   97:    size_type max_size() const noexcept;
        -:   98:
        -:   99:    iterator       begin() noexcept;
        -:  100:    iterator       end() noexcept;
        -:  101:    const_iterator begin()  const noexcept;
        -:  102:    const_iterator end()    const noexcept;
        -:  103:    const_iterator cbegin() const noexcept;
        -:  104:    const_iterator cend()   const noexcept;
        -:  105:
        -:  106:    template <class... Args>
        -:  107:        pair<iterator, bool> emplace(Args&&... args);
        -:  108:    template <class... Args>
        -:  109:        iterator emplace_hint(const_iterator position, Args&&... args);
        -:  110:    pair<iterator, bool> insert(const value_type& obj);
        -:  111:    pair<iterator, bool> insert(value_type&& obj);
        -:  112:    iterator insert(const_iterator hint, const value_type& obj);
        -:  113:    iterator insert(const_iterator hint, value_type&& obj);
        -:  114:    template <class InputIterator>
        -:  115:        void insert(InputIterator first, InputIterator last);
        -:  116:    void insert(initializer_list<value_type>);
        -:  117:
        -:  118:    node_type extract(const_iterator position);                       // C++17
        -:  119:    node_type extract(const key_type& x);                             // C++17
        -:  120:    insert_return_type insert(node_type&& nh);                        // C++17
        -:  121:    iterator           insert(const_iterator hint, node_type&& nh);   // C++17
        -:  122:
        -:  123:    iterator erase(const_iterator position);
        -:  124:    iterator erase(iterator position);  // C++14
        -:  125:    size_type erase(const key_type& k);
        -:  126:    iterator erase(const_iterator first, const_iterator last);
        -:  127:    void clear() noexcept;
        -:  128:
        -:  129:    template<class H2, class P2>
        -:  130:      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17
        -:  131:    template<class H2, class P2>
        -:  132:      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17
        -:  133:    template<class H2, class P2>
        -:  134:      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17
        -:  135:    template<class H2, class P2>
        -:  136:      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17
        -:  137:
        -:  138:    void swap(unordered_set&)
        -:  139:       noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        -:  140:                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&
        -:  141:                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17
        -:  142:
        -:  143:    hasher hash_function() const;
        -:  144:    key_equal key_eq() const;
        -:  145:
        -:  146:    iterator       find(const key_type& k);
        -:  147:    const_iterator find(const key_type& k) const;
        -:  148:    template<typename K>
        -:  149:        iterator find(const K& x);              // C++20
        -:  150:    template<typename K>
        -:  151:        const_iterator find(const K& x) const;  // C++20
        -:  152:    size_type count(const key_type& k) const;
        -:  153:    template<typename K>
        -:  154:        size_type count(const K& k) const; // C++20
        -:  155:    bool contains(const key_type& k) const; // C++20
        -:  156:    template<typename K>
        -:  157:        bool contains(const K& k) const; // C++20
        -:  158:    pair<iterator, iterator>             equal_range(const key_type& k);
        -:  159:    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
        -:  160:    template<typename K>
        -:  161:        pair<iterator, iterator>             equal_range(const K& k); // C++20
        -:  162:    template<typename K>
        -:  163:        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20
        -:  164:
        -:  165:    size_type bucket_count() const noexcept;
        -:  166:    size_type max_bucket_count() const noexcept;
        -:  167:
        -:  168:    size_type bucket_size(size_type n) const;
        -:  169:    size_type bucket(const key_type& k) const;
        -:  170:
        -:  171:    local_iterator       begin(size_type n);
        -:  172:    local_iterator       end(size_type n);
        -:  173:    const_local_iterator begin(size_type n) const;
        -:  174:    const_local_iterator end(size_type n) const;
        -:  175:    const_local_iterator cbegin(size_type n) const;
        -:  176:    const_local_iterator cend(size_type n) const;
        -:  177:
        -:  178:    float load_factor() const noexcept;
        -:  179:    float max_load_factor() const noexcept;
        -:  180:    void max_load_factor(float z);
        -:  181:    void rehash(size_type n);
        -:  182:    void reserve(size_type n);
        -:  183:};
        -:  184:
        -:  185:template<class InputIterator,
        -:  186:    class Hash = hash<typename iterator_traits<InputIterator>::value_type>,
        -:  187:    class Pred = equal_to<typename iterator_traits<InputIterator>::value_type>,
        -:  188:    class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
        -:  189:unordered_set(InputIterator, InputIterator, typename see below::size_type = see below,
        -:  190:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  191:  -> unordered_set<typename iterator_traits<InputIterator>::value_type,
        -:  192:        Hash, Pred, Allocator>; // C++17
        -:  193:
        -:  194:template<class T, class Hash = hash<T>,
        -:  195:          class Pred = equal_to<T>, class Allocator = allocator<T>>
        -:  196:unordered_set(initializer_list<T>, typename see below::size_type = see below,
        -:  197:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  198:  -> unordered_set<T, Hash, Pred, Allocator>; // C++17
        -:  199:
        -:  200:template<class InputIterator,  class Allocator>
        -:  201:unordered_set(InputIterator, InputIterator, typename see below::size_type, Allocator)
        -:  202:  -> unordered_set<typename iterator_traits<InputIterator>::value_type,
        -:  203:        hash<typename iterator_traits<InputIterator>::value_type>,
        -:  204:        equal_to<typename iterator_traits<InputIterator>::value_type>,
        -:  205:        Allocator>; // C++17
        -:  206:
        -:  207:template<class InputIterator, class Hash, class Allocator>
        -:  208:unordered_set(InputIterator, InputIterator, typename see below::size_type,
        -:  209:    Hash, Allocator)
        -:  210:  -> unordered_set<typename iterator_traits<InputIterator>::value_type, Hash,
        -:  211:        equal_to<typename iterator_traits<InputIterator>::value_type>,
        -:  212:        Allocator>; // C++17
        -:  213:
        -:  214:template<class T, class Allocator>
        -:  215:unordered_set(initializer_list<T>, typename see below::size_type, Allocator)
        -:  216:  -> unordered_set<T, hash<T>, equal_to<T>, Allocator>; // C++17
        -:  217:
        -:  218:template<class T, class Hash, class Allocator>
        -:  219:unordered_set(initializer_list<T>, typename see below::size_type, Hash, Allocator)
        -:  220:  -> unordered_set<T, Hash, equal_to<T>, Allocator>; // C++17
        -:  221:
        -:  222:template <class Value, class Hash, class Pred, class Alloc>
        -:  223:    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,
        -:  224:              unordered_set<Value, Hash, Pred, Alloc>& y)
        -:  225:              noexcept(noexcept(x.swap(y)));
        -:  226:
        -:  227:template <class Value, class Hash, class Pred, class Alloc>
        -:  228:    bool
        -:  229:    operator==(const unordered_set<Value, Hash, Pred, Alloc>& x,
        -:  230:               const unordered_set<Value, Hash, Pred, Alloc>& y);
        -:  231:
        -:  232:template <class Value, class Hash, class Pred, class Alloc>
        -:  233:    bool
        -:  234:    operator!=(const unordered_set<Value, Hash, Pred, Alloc>& x,
        -:  235:               const unordered_set<Value, Hash, Pred, Alloc>& y);
        -:  236:
        -:  237:template <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,
        -:  238:          class Alloc = allocator<Value>>
        -:  239:class unordered_multiset
        -:  240:{
        -:  241:public:
        -:  242:    // types
        -:  243:    typedef Value                                                      key_type;
        -:  244:    typedef key_type                                                   value_type;
        -:  245:    typedef Hash                                                       hasher;
        -:  246:    typedef Pred                                                       key_equal;
        -:  247:    typedef Alloc                                                      allocator_type;
        -:  248:    typedef value_type&                                                reference;
        -:  249:    typedef const value_type&                                          const_reference;
        -:  250:    typedef typename allocator_traits<allocator_type>::pointer         pointer;
        -:  251:    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;
        -:  252:    typedef typename allocator_traits<allocator_type>::size_type       size_type;
        -:  253:    typedef typename allocator_traits<allocator_type>::difference_type difference_type;
        -:  254:
        -:  255:    typedef /unspecified/ iterator;
        -:  256:    typedef /unspecified/ const_iterator;
        -:  257:    typedef /unspecified/ local_iterator;
        -:  258:    typedef /unspecified/ const_local_iterator;
        -:  259:
        -:  260:    typedef unspecified node_type unspecified;   // C++17
        -:  261:
        -:  262:    unordered_multiset()
        -:  263:        noexcept(
        -:  264:            is_nothrow_default_constructible<hasher>::value &&
        -:  265:            is_nothrow_default_constructible<key_equal>::value &&
        -:  266:            is_nothrow_default_constructible<allocator_type>::value);
        -:  267:    explicit unordered_multiset(size_type n, const hasher& hf = hasher(),
        -:  268:                           const key_equal& eql = key_equal(),
        -:  269:                           const allocator_type& a = allocator_type());
        -:  270:    template <class InputIterator>
        -:  271:        unordered_multiset(InputIterator f, InputIterator l,
        -:  272:                      size_type n = 0, const hasher& hf = hasher(),
        -:  273:                      const key_equal& eql = key_equal(),
        -:  274:                      const allocator_type& a = allocator_type());
        -:  275:    explicit unordered_multiset(const allocator_type&);
        -:  276:    unordered_multiset(const unordered_multiset&);
        -:  277:    unordered_multiset(const unordered_multiset&, const Allocator&);
        -:  278:    unordered_multiset(unordered_multiset&&)
        -:  279:        noexcept(
        -:  280:            is_nothrow_move_constructible<hasher>::value &&
        -:  281:            is_nothrow_move_constructible<key_equal>::value &&
        -:  282:            is_nothrow_move_constructible<allocator_type>::value);
        -:  283:    unordered_multiset(unordered_multiset&&, const Allocator&);
        -:  284:    unordered_multiset(initializer_list<value_type>, size_type n = /see below/,
        -:  285:                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),
        -:  286:                  const allocator_type& a = allocator_type());
        -:  287:    unordered_multiset(size_type n, const allocator_type& a); // C++14
        -:  288:    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a); // C++14
        -:  289:    template <class InputIterator>
        -:  290:      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14
        -:  291:    template <class InputIterator>
        -:  292:      unordered_multiset(InputIterator f, InputIterator l, size_type n,
        -:  293:                         const hasher& hf, const allocator_type& a); // C++14
        -:  294:    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14
        -:  295:    unordered_multiset(initializer_list<value_type> il, size_type n,
        -:  296:                       const hasher& hf,  const allocator_type& a); // C++14
        -:  297:    ~unordered_multiset();
        -:  298:    unordered_multiset& operator=(const unordered_multiset&);
        -:  299:    unordered_multiset& operator=(unordered_multiset&&)
        -:  300:        noexcept(
        -:  301:            allocator_type::propagate_on_container_move_assignment::value &&
        -:  302:            is_nothrow_move_assignable<allocator_type>::value &&
        -:  303:            is_nothrow_move_assignable<hasher>::value &&
        -:  304:            is_nothrow_move_assignable<key_equal>::value);
        -:  305:    unordered_multiset& operator=(initializer_list<value_type>);
        -:  306:
        -:  307:    allocator_type get_allocator() const noexcept;
        -:  308:
        -:  309:    bool      empty() const noexcept;
        -:  310:    size_type size() const noexcept;
        -:  311:    size_type max_size() const noexcept;
        -:  312:
        -:  313:    iterator       begin() noexcept;
        -:  314:    iterator       end() noexcept;
        -:  315:    const_iterator begin()  const noexcept;
        -:  316:    const_iterator end()    const noexcept;
        -:  317:    const_iterator cbegin() const noexcept;
        -:  318:    const_iterator cend()   const noexcept;
        -:  319:
        -:  320:    template <class... Args>
        -:  321:        iterator emplace(Args&&... args);
        -:  322:    template <class... Args>
        -:  323:        iterator emplace_hint(const_iterator position, Args&&... args);
        -:  324:    iterator insert(const value_type& obj);
        -:  325:    iterator insert(value_type&& obj);
        -:  326:    iterator insert(const_iterator hint, const value_type& obj);
        -:  327:    iterator insert(const_iterator hint, value_type&& obj);
        -:  328:    template <class InputIterator>
        -:  329:        void insert(InputIterator first, InputIterator last);
        -:  330:    void insert(initializer_list<value_type>);
        -:  331:
        -:  332:    node_type extract(const_iterator position);             // C++17
        -:  333:    node_type extract(const key_type& x);                   // C++17
        -:  334:    iterator insert(node_type&& nh);                        // C++17
        -:  335:    iterator insert(const_iterator hint, node_type&& nh);   // C++17
        -:  336:
        -:  337:    iterator erase(const_iterator position);
        -:  338:    iterator erase(iterator position);  // C++14
        -:  339:    size_type erase(const key_type& k);
        -:  340:    iterator erase(const_iterator first, const_iterator last);
        -:  341:    void clear() noexcept;
        -:  342:
        -:  343:    template<class H2, class P2>
        -:  344:      void merge(unordered_multiset<Key, H2, P2, Allocator>& source);    // C++17
        -:  345:    template<class H2, class P2>
        -:  346:      void merge(unordered_multiset<Key, H2, P2, Allocator>&& source);   // C++17
        -:  347:    template<class H2, class P2>
        -:  348:      void merge(unordered_set<Key, H2, P2, Allocator>& source);         // C++17
        -:  349:    template<class H2, class P2>
        -:  350:      void merge(unordered_set<Key, H2, P2, Allocator>&& source);        // C++17
        -:  351:
        -:  352:    void swap(unordered_multiset&)
        -:  353:       noexcept(allocator_traits<Allocator>::is_always_equal::value &&
        -:  354:                 noexcept(swap(declval<hasher&>(), declval<hasher&>())) &&
        -:  355:                 noexcept(swap(declval<key_equal&>(), declval<key_equal&>()))); // C++17
        -:  356:
        -:  357:    hasher hash_function() const;
        -:  358:    key_equal key_eq() const;
        -:  359:
        -:  360:    iterator       find(const key_type& k);
        -:  361:    const_iterator find(const key_type& k) const;
        -:  362:    template<typename K>
        -:  363:        iterator find(const K& x);              // C++20
        -:  364:    template<typename K>
        -:  365:        const_iterator find(const K& x) const;  // C++20
        -:  366:    size_type count(const key_type& k) const;
        -:  367:    template<typename K>
        -:  368:        size_type count(const K& k) const; // C++20
        -:  369:    bool contains(const key_type& k) const; // C++20
        -:  370:    template<typename K>
        -:  371:        bool contains(const K& k) const; // C++20
        -:  372:    pair<iterator, iterator>             equal_range(const key_type& k);
        -:  373:    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;
        -:  374:    template<typename K>
        -:  375:        pair<iterator, iterator>             equal_range(const K& k); // C++20
        -:  376:    template<typename K>
        -:  377:        pair<const_iterator, const_iterator> equal_range(const K& k) const; // C++20
        -:  378:
        -:  379:    size_type bucket_count() const noexcept;
        -:  380:    size_type max_bucket_count() const noexcept;
        -:  381:
        -:  382:    size_type bucket_size(size_type n) const;
        -:  383:    size_type bucket(const key_type& k) const;
        -:  384:
        -:  385:    local_iterator       begin(size_type n);
        -:  386:    local_iterator       end(size_type n);
        -:  387:    const_local_iterator begin(size_type n) const;
        -:  388:    const_local_iterator end(size_type n) const;
        -:  389:    const_local_iterator cbegin(size_type n) const;
        -:  390:    const_local_iterator cend(size_type n) const;
        -:  391:
        -:  392:    float load_factor() const noexcept;
        -:  393:    float max_load_factor() const noexcept;
        -:  394:    void max_load_factor(float z);
        -:  395:    void rehash(size_type n);
        -:  396:    void reserve(size_type n);
        -:  397:};
        -:  398:
        -:  399:template<class InputIterator,
        -:  400:    class Hash = hash<typename iterator_traits<InputIterator>::value_type>,
        -:  401:    class Pred = equal_to<typename iterator_traits<InputIterator>::value_type>,
        -:  402:    class Allocator = allocator<typename iterator_traits<InputIterator>::value_type>>
        -:  403:unordered_multiset(InputIterator, InputIterator, see below::size_type = see below,
        -:  404:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  405:  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type,
        -:  406:        Hash, Pred, Allocator>; // C++17
        -:  407:
        -:  408:template<class T, class Hash = hash<T>,
        -:  409:          class Pred = equal_to<T>, class Allocator = allocator<T>>
        -:  410:unordered_multiset(initializer_list<T>, typename see below::size_type = see below,
        -:  411:    Hash = Hash(), Pred = Pred(), Allocator = Allocator())
        -:  412:  -> unordered_multiset<T, Hash, Pred, Allocator>; // C++17
        -:  413:
        -:  414:template<class InputIterator,  class Allocator>
        -:  415:unordered_multiset(InputIterator, InputIterator, typename see below::size_type, Allocator)
        -:  416:  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type,
        -:  417:        hash<typename iterator_traits<InputIterator>::value_type>,
        -:  418:        equal_to<typename iterator_traits<InputIterator>::value_type>,
        -:  419:        Allocator>; // C++17
        -:  420:
        -:  421:template<class InputIterator,  class Hash, class Allocator>
        -:  422:unordered_multiset(InputIterator, InputIterator, typename see below::size_type,
        -:  423:    Hash, Allocator)
        -:  424:  -> unordered_multiset<typename iterator_traits<InputIterator>::value_type, Hash,
        -:  425:        equal_to<typename iterator_traits<InputIterator>::value_type>, Allocator>; // C++17
        -:  426:
        -:  427:template<class T, class Allocator>
        -:  428:unordered_multiset(initializer_list<T>, typename see below::size_type, Allocator)
        -:  429:  -> unordered_multiset<T, hash<T>, equal_to<T>, Allocator>; // C++17
        -:  430:
        -:  431:template<class T, class Hash, class Allocator>
        -:  432:unordered_multiset(initializer_list<T>, typename see below::size_type, Hash, Allocator)
        -:  433:  -> unordered_multiset<T, Hash, equal_to<T>, Allocator>; // C++17
        -:  434:
        -:  435:template <class Value, class Hash, class Pred, class Alloc>
        -:  436:    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,
        -:  437:              unordered_multiset<Value, Hash, Pred, Alloc>& y)
        -:  438:              noexcept(noexcept(x.swap(y)));
        -:  439:
        -:  440:template <class K, class T, class H, class P, class A, class Predicate>
        -:  441:    typename unordered_set<K, T, H, P, A>::size_type
        -:  442:    erase_if(unordered_set<K, T, H, P, A>& c, Predicate pred);       // C++20
        -:  443:
        -:  444:template <class K, class T, class H, class P, class A, class Predicate>
        -:  445:    typename unordered_multiset<K, T, H, P, A>::size_type
        -:  446:    erase_if(unordered_multiset<K, T, H, P, A>& c, Predicate pred);  // C++20
        -:  447:
        -:  448:
        -:  449:template <class Value, class Hash, class Pred, class Alloc>
        -:  450:    bool
        -:  451:    operator==(const unordered_multiset<Value, Hash, Pred, Alloc>& x,
        -:  452:               const unordered_multiset<Value, Hash, Pred, Alloc>& y);
        -:  453:
        -:  454:template <class Value, class Hash, class Pred, class Alloc>
        -:  455:    bool
        -:  456:    operator!=(const unordered_multiset<Value, Hash, Pred, Alloc>& x,
        -:  457:               const unordered_multiset<Value, Hash, Pred, Alloc>& y);
        -:  458:}  // std
        -:  459:
        -:  460:*/
        -:  461:
        -:  462:#include <__algorithm/is_permutation.h>
        -:  463:#include <__assert> // all public C++ headers provide the assertion handler
        -:  464:#include <__config>
        -:  465:#include <__debug>
        -:  466:#include <__functional/is_transparent.h>
        -:  467:#include <__functional/operations.h>
        -:  468:#include <__hash_table>
        -:  469:#include <__iterator/distance.h>
        -:  470:#include <__iterator/erase_if_container.h>
        -:  471:#include <__iterator/iterator_traits.h>
        -:  472:#include <__memory/addressof.h>
        -:  473:#include <__node_handle>
        -:  474:#include <__utility/forward.h>
        -:  475:#include <version>
        -:  476:
        -:  477:#ifndef _LIBCPP_REMOVE_TRANSITIVE_INCLUDES
        -:  478:#  include <functional>
        -:  479:#  include <iterator>
        -:  480:#endif
        -:  481:
        -:  482:// standard-mandated includes
        -:  483:
        -:  484:// [iterator.range]
        -:  485:#include <__iterator/access.h>
        -:  486:#include <__iterator/data.h>
        -:  487:#include <__iterator/empty.h>
        -:  488:#include <__iterator/reverse_access.h>
        -:  489:#include <__iterator/size.h>
        -:  490:
        -:  491:// [unord.set.syn]
        -:  492:#include <compare>
        -:  493:#include <initializer_list>
        -:  494:
        -:  495:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  496:#  pragma GCC system_header
        -:  497:#endif
        -:  498:
        -:  499:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  500:
        -:  501:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  502:class unordered_multiset;
        -:  503:
        -:  504:template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
        -:  505:          class _Alloc = allocator<_Value> >
        -:  506:class _LIBCPP_TEMPLATE_VIS unordered_set
        -:  507:{
        -:  508:public:
        -:  509:    // types
        -:  510:    typedef _Value                                                     key_type;
        -:  511:    typedef key_type                                                   value_type;
        -:  512:    typedef __type_identity_t<_Hash>                                   hasher;
        -:  513:    typedef __type_identity_t<_Pred>                                   key_equal;
        -:  514:    typedef __type_identity_t<_Alloc>                                  allocator_type;
        -:  515:    typedef value_type&                                                reference;
        -:  516:    typedef const value_type&                                          const_reference;
        -:  517:    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
        -:  518:                  "Invalid allocator::value_type");
        -:  519:
        -:  520:private:
        -:  521:    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;
        -:  522:
        -:  523:    __table __table_;
        -:  524:
        -:  525:public:
        -:  526:    typedef typename __table::pointer         pointer;
        -:  527:    typedef typename __table::const_pointer   const_pointer;
        -:  528:    typedef typename __table::size_type       size_type;
        -:  529:    typedef typename __table::difference_type difference_type;
        -:  530:
        -:  531:    typedef typename __table::const_iterator       iterator;
        -:  532:    typedef typename __table::const_iterator       const_iterator;
        -:  533:    typedef typename __table::const_local_iterator local_iterator;
        -:  534:    typedef typename __table::const_local_iterator const_local_iterator;
        -:  535:
        -:  536:#if _LIBCPP_STD_VER > 14
        -:  537:    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;
        -:  538:    typedef __insert_return_type<iterator, node_type> insert_return_type;
        -:  539:#endif
        -:  540:
        -:  541:    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        -:  542:        friend class _LIBCPP_TEMPLATE_VIS unordered_set;
        -:  543:    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        -:  544:        friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;
        -:  545:
        -:  546:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEEC1B6v15006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEEC2B6v15006Ev called 1 returned 100% blocks executed 66%
        2:  547:    unordered_set()
        -:  548:        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)
        1:  549:    {
        1:  550:        _VSTD::__debug_db_insert_c(this);
        1:  550-block  0
branch  0 taken 1
branch  1 taken 0
    $$$$$:  550-block  1
        2:  551:    }
        1:  551-block  0
        1:  551-block  1
        -:  552:    explicit unordered_set(size_type __n, const hasher& __hf = hasher(),
        -:  553:                           const key_equal& __eql = key_equal());
        -:  554:#if _LIBCPP_STD_VER > 11
        -:  555:    inline _LIBCPP_INLINE_VISIBILITY
        -:  556:    unordered_set(size_type __n, const allocator_type& __a)
        -:  557:        : unordered_set(__n, hasher(), key_equal(), __a) {}
        -:  558:    inline _LIBCPP_INLINE_VISIBILITY
        -:  559:    unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)
        -:  560:        : unordered_set(__n, __hf, key_equal(), __a) {}
        -:  561:#endif
        -:  562:    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,
        -:  563:                  const allocator_type& __a);
        -:  564:    template <class _InputIterator>
        -:  565:        unordered_set(_InputIterator __first, _InputIterator __last);
        -:  566:    template <class _InputIterator>
        -:  567:        unordered_set(_InputIterator __first, _InputIterator __last,
        -:  568:                      size_type __n, const hasher& __hf = hasher(),
        -:  569:                      const key_equal& __eql = key_equal());
        -:  570:    template <class _InputIterator>
        -:  571:        unordered_set(_InputIterator __first, _InputIterator __last,
        -:  572:                      size_type __n, const hasher& __hf, const key_equal& __eql,
        -:  573:                      const allocator_type& __a);
        -:  574:#if _LIBCPP_STD_VER > 11
        -:  575:    template <class _InputIterator>
        -:  576:    inline _LIBCPP_INLINE_VISIBILITY
        -:  577:        unordered_set(_InputIterator __first, _InputIterator __last,
        -:  578:                    size_type __n, const allocator_type& __a)
        -:  579:            : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}
        -:  580:    template <class _InputIterator>
        -:  581:        unordered_set(_InputIterator __first, _InputIterator __last,
        -:  582:                      size_type __n, const hasher& __hf, const allocator_type& __a)
        -:  583:            : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}
        -:  584:#endif
        -:  585:    _LIBCPP_INLINE_VISIBILITY
        -:  586:    explicit unordered_set(const allocator_type& __a);
        -:  587:    unordered_set(const unordered_set& __u);
        -:  588:    unordered_set(const unordered_set& __u, const allocator_type& __a);
        -:  589:#ifndef _LIBCPP_CXX03_LANG
        -:  590:    _LIBCPP_INLINE_VISIBILITY
        -:  591:    unordered_set(unordered_set&& __u)
        -:  592:        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
        -:  593:    unordered_set(unordered_set&& __u, const allocator_type& __a);
        1:  594:    unordered_set(initializer_list<value_type> __il);
        -:  595:    unordered_set(initializer_list<value_type> __il, size_type __n,
        -:  596:                  const hasher& __hf = hasher(),
        -:  597:                  const key_equal& __eql = key_equal());
        -:  598:    unordered_set(initializer_list<value_type> __il, size_type __n,
        -:  599:                  const hasher& __hf, const key_equal& __eql,
        -:  600:                  const allocator_type& __a);
        -:  601:#if _LIBCPP_STD_VER > 11
        -:  602:    inline _LIBCPP_INLINE_VISIBILITY
        -:  603:    unordered_set(initializer_list<value_type> __il, size_type __n,
        -:  604:                                                      const allocator_type& __a)
        -:  605:        : unordered_set(__il, __n, hasher(), key_equal(), __a) {}
        -:  606:    inline _LIBCPP_INLINE_VISIBILITY
        -:  607:    unordered_set(initializer_list<value_type> __il, size_type __n,
        -:  608:                                  const hasher& __hf, const allocator_type& __a)
        -:  609:        : unordered_set(__il, __n, __hf, key_equal(), __a) {}
        -:  610:#endif
        -:  611:#endif // _LIBCPP_CXX03_LANG
        -:  612:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEED1B6v15006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEED2B6v15006Ev called 1 returned 100% blocks executed 100%
function _ZNSt3__113unordered_setIP5GraphNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEED1B6v15006Ev called 22 returned 100% blocks executed 100%
function _ZNSt3__113unordered_setIP5GraphNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEED2B6v15006Ev called 22 returned 100% blocks executed 100%
       46:  613:    ~unordered_set() {
        -:  614:        static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
       46:  615:    }
        1:  615-block  0
        1:  615-block  1
       22:  615-block  2
       22:  615-block  3
        -:  616:
        -:  617:    _LIBCPP_INLINE_VISIBILITY
        -:  618:    unordered_set& operator=(const unordered_set& __u)
        -:  619:    {
        -:  620:        __table_ = __u.__table_;
        -:  621:        return *this;
        -:  622:    }
        -:  623:#ifndef _LIBCPP_CXX03_LANG
        -:  624:    _LIBCPP_INLINE_VISIBILITY
        -:  625:    unordered_set& operator=(unordered_set&& __u)
        -:  626:        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
        -:  627:    _LIBCPP_INLINE_VISIBILITY
        -:  628:    unordered_set& operator=(initializer_list<value_type> __il);
        -:  629:#endif // _LIBCPP_CXX03_LANG
        -:  630:
        -:  631:    _LIBCPP_INLINE_VISIBILITY
        -:  632:    allocator_type get_allocator() const _NOEXCEPT
        -:  633:        {return allocator_type(__table_.__node_alloc());}
        -:  634:
        -:  635:    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY
        -:  636:    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}
        -:  637:    _LIBCPP_INLINE_VISIBILITY
        -:  638:    size_type size() const _NOEXCEPT  {return __table_.size();}
        -:  639:    _LIBCPP_INLINE_VISIBILITY
        -:  640:    size_type max_size() const _NOEXCEPT {return __table_.max_size();}
        -:  641:
        -:  642:    _LIBCPP_INLINE_VISIBILITY
        -:  643:    iterator       begin() _NOEXCEPT        {return __table_.begin();}
        -:  644:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEE3endB6v15006Ev called 7 returned 100% blocks executed 100%
        7:  645:    iterator       end() _NOEXCEPT          {return __table_.end();}
        7:  645-block  0
        -:  646:    _LIBCPP_INLINE_VISIBILITY
        -:  647:    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}
        -:  648:    _LIBCPP_INLINE_VISIBILITY
        -:  649:    const_iterator end()    const _NOEXCEPT {return __table_.end();}
        -:  650:    _LIBCPP_INLINE_VISIBILITY
        -:  651:    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}
        -:  652:    _LIBCPP_INLINE_VISIBILITY
        -:  653:    const_iterator cend()   const _NOEXCEPT {return __table_.end();}
        -:  654:
        -:  655:#ifndef _LIBCPP_CXX03_LANG
        -:  656:    template <class... _Args>
        -:  657:        _LIBCPP_INLINE_VISIBILITY
        -:  658:        pair<iterator, bool> emplace(_Args&&... __args)
        -:  659:            {return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}
        -:  660:    template <class... _Args>
        -:  661:    _LIBCPP_INLINE_VISIBILITY
        -:  662:    iterator emplace_hint(const_iterator __p, _Args&&... __args) {
        -:  663:        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__find_c_from_i(std::addressof(__p)) == this,
        -:  664:            "unordered_set::emplace_hint(const_iterator, args...) called with an iterator not"
        -:  665:            " referring to this unordered_set");
        -:  666:        (void)__p;
        -:  667:        return __table_.__emplace_unique(std::forward<_Args>(__args)...).first;
        -:  668:    }
        -:  669:
        -:  670:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEE6insertB6v15006EOy called 8 returned 100% blocks executed 100%
        8:  671:    pair<iterator, bool> insert(value_type&& __x)
        8:  672:        {return __table_.__insert_unique(_VSTD::move(__x));}
        8:  672-block  0
        -:  673:    _LIBCPP_INLINE_VISIBILITY
        -:  674:    iterator insert(const_iterator __p, value_type&& __x) {
        -:  675:        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__find_c_from_i(std::addressof(__p)) == this,
        -:  676:            "unordered_set::insert(const_iterator, value_type&&) called with an iterator not"
        -:  677:            " referring to this unordered_set");
        -:  678:        (void)__p;
        -:  679:        return insert(std::move(__x)).first;
        -:  680:    }
        -:  681:
        -:  682:    _LIBCPP_INLINE_VISIBILITY
        -:  683:    void insert(initializer_list<value_type> __il)
        -:  684:        {insert(__il.begin(), __il.end());}
        -:  685:#endif // _LIBCPP_CXX03_LANG
        -:  686:    _LIBCPP_INLINE_VISIBILITY
        -:  687:    pair<iterator, bool> insert(const value_type& __x)
        -:  688:        {return __table_.__insert_unique(__x);}
        -:  689:
        -:  690:    _LIBCPP_INLINE_VISIBILITY
        -:  691:    iterator insert(const_iterator __p, const value_type& __x) {
        -:  692:        _LIBCPP_DEBUG_ASSERT(__get_const_db()->__find_c_from_i(std::addressof(__p)) == this,
        -:  693:            "unordered_set::insert(const_iterator, const value_type&) called with an iterator not"
        -:  694:            " referring to this unordered_set");
        -:  695:        (void)__p;
        -:  696:        return insert(__x).first;
        -:  697:    }
        -:  698:    template <class _InputIterator>
        -:  699:        _LIBCPP_INLINE_VISIBILITY
        -:  700:        void insert(_InputIterator __first, _InputIterator __last);
        -:  701:
        -:  702:    _LIBCPP_INLINE_VISIBILITY
        -:  703:    iterator erase(const_iterator __p) {return __table_.erase(__p);}
        -:  704:    _LIBCPP_INLINE_VISIBILITY
        -:  705:    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}
        -:  706:    _LIBCPP_INLINE_VISIBILITY
        -:  707:    iterator erase(const_iterator __first, const_iterator __last)
        -:  708:        {return __table_.erase(__first, __last);}
        -:  709:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEE5clearB6v15006Ev called 1 returned 100% blocks executed 100%
        1:  710:    void clear() _NOEXCEPT {__table_.clear();}
        1:  710-block  0
        -:  711:
        -:  712:#if _LIBCPP_STD_VER > 14
        -:  713:    _LIBCPP_INLINE_VISIBILITY
        -:  714:    insert_return_type insert(node_type&& __nh)
        -:  715:    {
        -:  716:        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -:  717:            "node_type with incompatible allocator passed to unordered_set::insert()");
        -:  718:        return __table_.template __node_handle_insert_unique<
        -:  719:            node_type, insert_return_type>(_VSTD::move(__nh));
        -:  720:    }
        -:  721:    _LIBCPP_INLINE_VISIBILITY
        -:  722:    iterator insert(const_iterator __h, node_type&& __nh)
        -:  723:    {
        -:  724:        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -:  725:            "node_type with incompatible allocator passed to unordered_set::insert()");
        -:  726:        return __table_.template __node_handle_insert_unique<node_type>(
        -:  727:            __h, _VSTD::move(__nh));
        -:  728:    }
        -:  729:    _LIBCPP_INLINE_VISIBILITY
        -:  730:    node_type extract(key_type const& __key)
        -:  731:    {
        -:  732:        return __table_.template __node_handle_extract<node_type>(__key);
        -:  733:    }
        -:  734:    _LIBCPP_INLINE_VISIBILITY
        -:  735:    node_type extract(const_iterator __it)
        -:  736:    {
        -:  737:        return __table_.template __node_handle_extract<node_type>(__it);
        -:  738:    }
        -:  739:
        -:  740:    template<class _H2, class _P2>
        -:  741:    _LIBCPP_INLINE_VISIBILITY
        -:  742:    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)
        -:  743:    {
        -:  744:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -:  745:                       "merging container with incompatible allocator");
        -:  746:        __table_.__node_handle_merge_unique(__source.__table_);
        -:  747:    }
        -:  748:    template<class _H2, class _P2>
        -:  749:    _LIBCPP_INLINE_VISIBILITY
        -:  750:    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)
        -:  751:    {
        -:  752:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -:  753:                       "merging container with incompatible allocator");
        -:  754:        __table_.__node_handle_merge_unique(__source.__table_);
        -:  755:    }
        -:  756:    template<class _H2, class _P2>
        -:  757:    _LIBCPP_INLINE_VISIBILITY
        -:  758:    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)
        -:  759:    {
        -:  760:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -:  761:                       "merging container with incompatible allocator");
        -:  762:        __table_.__node_handle_merge_unique(__source.__table_);
        -:  763:    }
        -:  764:    template<class _H2, class _P2>
        -:  765:    _LIBCPP_INLINE_VISIBILITY
        -:  766:    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)
        -:  767:    {
        -:  768:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -:  769:                       "merging container with incompatible allocator");
        -:  770:        __table_.__node_handle_merge_unique(__source.__table_);
        -:  771:    }
        -:  772:#endif
        -:  773:
        -:  774:    _LIBCPP_INLINE_VISIBILITY
        -:  775:    void swap(unordered_set& __u)
        -:  776:        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)
        -:  777:        {__table_.swap(__u.__table_);}
        -:  778:
        -:  779:    _LIBCPP_INLINE_VISIBILITY
        -:  780:    hasher hash_function() const {return __table_.hash_function();}
        -:  781:    _LIBCPP_INLINE_VISIBILITY
        -:  782:    key_equal key_eq() const {return __table_.key_eq();}
        -:  783:
        -:  784:    _LIBCPP_INLINE_VISIBILITY
function _ZNSt3__113unordered_setIyNS_4hashIyEENS_8equal_toIyEENS_9allocatorIyEEE4findB6v15006ERKy called 7 returned 100% blocks executed 100%
        7:  785:    iterator       find(const key_type& __k)       {return __table_.find(__k);}
        7:  785-block  0
        -:  786:    _LIBCPP_INLINE_VISIBILITY
        -:  787:    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
        -:  788:#if _LIBCPP_STD_VER > 17
        -:  789:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  790:    _LIBCPP_INLINE_VISIBILITY
        -:  791:    iterator       find(const _K2& __k)            {return __table_.find(__k);}
        -:  792:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  793:    _LIBCPP_INLINE_VISIBILITY
        -:  794:    const_iterator find(const _K2& __k) const      {return __table_.find(__k);}
        -:  795:#endif // _LIBCPP_STD_VER > 17
        -:  796:
        -:  797:    _LIBCPP_INLINE_VISIBILITY
        -:  798:    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}
        -:  799:#if _LIBCPP_STD_VER > 17
        -:  800:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  801:    _LIBCPP_INLINE_VISIBILITY
        -:  802:    size_type count(const _K2& __k) const      {return __table_.__count_unique(__k);}
        -:  803:#endif // _LIBCPP_STD_VER > 17
        -:  804:
        -:  805:#if _LIBCPP_STD_VER > 17
        -:  806:    _LIBCPP_INLINE_VISIBILITY
        -:  807:    bool contains(const key_type& __k) const {return find(__k) != end();}
        -:  808:
        -:  809:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  810:    _LIBCPP_INLINE_VISIBILITY
        -:  811:    bool contains(const _K2& __k) const      {return find(__k) != end();}
        -:  812:#endif // _LIBCPP_STD_VER > 17
        -:  813:
        -:  814:    _LIBCPP_INLINE_VISIBILITY
        -:  815:    pair<iterator, iterator>             equal_range(const key_type& __k)
        -:  816:        {return __table_.__equal_range_unique(__k);}
        -:  817:    _LIBCPP_INLINE_VISIBILITY
        -:  818:    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        -:  819:        {return __table_.__equal_range_unique(__k);}
        -:  820:#if _LIBCPP_STD_VER > 17
        -:  821:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  822:    _LIBCPP_INLINE_VISIBILITY
        -:  823:    pair<iterator, iterator>             equal_range(const _K2& __k)
        -:  824:        {return __table_.__equal_range_unique(__k);}
        -:  825:    template <class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -:  826:    _LIBCPP_INLINE_VISIBILITY
        -:  827:    pair<const_iterator, const_iterator> equal_range(const _K2& __k) const
        -:  828:        {return __table_.__equal_range_unique(__k);}
        -:  829:#endif // _LIBCPP_STD_VER > 17
        -:  830:
        -:  831:    _LIBCPP_INLINE_VISIBILITY
        -:  832:    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}
        -:  833:    _LIBCPP_INLINE_VISIBILITY
        -:  834:    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}
        -:  835:
        -:  836:    _LIBCPP_INLINE_VISIBILITY
        -:  837:    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
        -:  838:    _LIBCPP_INLINE_VISIBILITY
        -:  839:    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}
        -:  840:
        -:  841:    _LIBCPP_INLINE_VISIBILITY
        -:  842:    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}
        -:  843:    _LIBCPP_INLINE_VISIBILITY
        -:  844:    local_iterator       end(size_type __n)          {return __table_.end(__n);}
        -:  845:    _LIBCPP_INLINE_VISIBILITY
        -:  846:    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}
        -:  847:    _LIBCPP_INLINE_VISIBILITY
        -:  848:    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}
        -:  849:    _LIBCPP_INLINE_VISIBILITY
        -:  850:    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
        -:  851:    _LIBCPP_INLINE_VISIBILITY
        -:  852:    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}
        -:  853:
        -:  854:    _LIBCPP_INLINE_VISIBILITY
        -:  855:    float load_factor() const _NOEXCEPT {return __table_.load_factor();}
        -:  856:    _LIBCPP_INLINE_VISIBILITY
        -:  857:    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}
        -:  858:    _LIBCPP_INLINE_VISIBILITY
        -:  859:    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
        -:  860:    _LIBCPP_INLINE_VISIBILITY
        -:  861:    void rehash(size_type __n) {__table_.__rehash_unique(__n);}
        -:  862:    _LIBCPP_INLINE_VISIBILITY
        -:  863:    void reserve(size_type __n) {__table_.__reserve_unique(__n);}
        -:  864:
        -:  865:#ifdef _LIBCPP_ENABLE_DEBUG_MODE
        -:  866:
        -:  867:    bool __dereferenceable(const const_iterator* __i) const
        -:  868:        {return __table_.__dereferenceable(__i);}
        -:  869:    bool __decrementable(const const_iterator* __i) const
        -:  870:        {return __table_.__decrementable(__i);}
        -:  871:    bool __addable(const const_iterator* __i, ptrdiff_t __n) const
        -:  872:        {return __table_.__addable(__i, __n);}
        -:  873:    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const
        -:  874:        {return __table_.__addable(__i, __n);}
        -:  875:
        -:  876:#endif // _LIBCPP_ENABLE_DEBUG_MODE
        -:  877:
        -:  878:};
        -:  879:
        -:  880:#if _LIBCPP_STD_VER >= 17
        -:  881:template<class _InputIterator,
        -:  882:         class _Hash = hash<__iter_value_type<_InputIterator>>,
        -:  883:         class _Pred = equal_to<__iter_value_type<_InputIterator>>,
        -:  884:         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
        -:  885:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -:  886:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -:  887:         class = enable_if_t<!is_integral<_Hash>::value>,
        -:  888:         class = enable_if_t<!__is_allocator<_Pred>::value>,
        -:  889:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  890:unordered_set(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
        -:  891:              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
        -:  892:  -> unordered_set<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;
        -:  893:
        -:  894:template<class _Tp, class _Hash = hash<_Tp>,
        -:  895:         class _Pred = equal_to<_Tp>,
        -:  896:         class _Allocator = allocator<_Tp>,
        -:  897:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -:  898:         class = enable_if_t<!is_integral<_Hash>::value>,
        -:  899:         class = enable_if_t<!__is_allocator<_Pred>::value>,
        -:  900:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  901:unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type = 0,
        -:  902:              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
        -:  903:  -> unordered_set<_Tp, _Hash, _Pred, _Allocator>;
        -:  904:
        -:  905:template<class _InputIterator, class _Allocator,
        -:  906:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -:  907:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  908:unordered_set(_InputIterator, _InputIterator,
        -:  909:              typename allocator_traits<_Allocator>::size_type, _Allocator)
        -:  910:  -> unordered_set<__iter_value_type<_InputIterator>,
        -:  911:                   hash<__iter_value_type<_InputIterator>>,
        -:  912:                   equal_to<__iter_value_type<_InputIterator>>,
        -:  913:                   _Allocator>;
        -:  914:
        -:  915:template<class _InputIterator, class _Hash, class _Allocator,
        -:  916:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -:  917:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -:  918:         class = enable_if_t<!is_integral<_Hash>::value>,
        -:  919:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  920:unordered_set(_InputIterator, _InputIterator,
        -:  921:              typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -:  922:  -> unordered_set<__iter_value_type<_InputIterator>, _Hash,
        -:  923:                   equal_to<__iter_value_type<_InputIterator>>,
        -:  924:                   _Allocator>;
        -:  925:
        -:  926:template<class _Tp, class _Allocator,
        -:  927:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  928:unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -:  929:  -> unordered_set<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;
        -:  930:
        -:  931:template<class _Tp, class _Hash, class _Allocator,
        -:  932:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -:  933:         class = enable_if_t<!is_integral<_Hash>::value>,
        -:  934:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -:  935:unordered_set(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -:  936:  -> unordered_set<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
        -:  937:#endif
        -:  938:
        -:  939:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  940:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        -:  941:        const hasher& __hf, const key_equal& __eql)
        -:  942:    : __table_(__hf, __eql)
        -:  943:{
        -:  944:    _VSTD::__debug_db_insert_c(this);
        -:  945:    __table_.__rehash_unique(__n);
        -:  946:}
        -:  947:
        -:  948:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  949:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,
        -:  950:        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
        -:  951:    : __table_(__hf, __eql, __a)
        -:  952:{
        -:  953:    _VSTD::__debug_db_insert_c(this);
        -:  954:    __table_.__rehash_unique(__n);
        -:  955:}
        -:  956:
        -:  957:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  958:template <class _InputIterator>
        -:  959:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -:  960:        _InputIterator __first, _InputIterator __last)
        -:  961:{
        -:  962:    _VSTD::__debug_db_insert_c(this);
        -:  963:    insert(__first, __last);
        -:  964:}
        -:  965:
        -:  966:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  967:template <class _InputIterator>
        -:  968:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -:  969:        _InputIterator __first, _InputIterator __last, size_type __n,
        -:  970:        const hasher& __hf, const key_equal& __eql)
        -:  971:    : __table_(__hf, __eql)
        -:  972:{
        -:  973:    _VSTD::__debug_db_insert_c(this);
        -:  974:    __table_.__rehash_unique(__n);
        -:  975:    insert(__first, __last);
        -:  976:}
        -:  977:
        -:  978:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  979:template <class _InputIterator>
        -:  980:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -:  981:        _InputIterator __first, _InputIterator __last, size_type __n,
        -:  982:        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
        -:  983:    : __table_(__hf, __eql, __a)
        -:  984:{
        -:  985:    _VSTD::__debug_db_insert_c(this);
        -:  986:    __table_.__rehash_unique(__n);
        -:  987:    insert(__first, __last);
        -:  988:}
        -:  989:
        -:  990:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -:  991:inline
        -:  992:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -:  993:        const allocator_type& __a)
        -:  994:    : __table_(__a)
        -:  995:{
        -:  996:    _VSTD::__debug_db_insert_c(this);
        -:  997:}
        -:  998:
        -:  999:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1000:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1001:        const unordered_set& __u)
        -: 1002:    : __table_(__u.__table_)
        -: 1003:{
        -: 1004:    _VSTD::__debug_db_insert_c(this);
        -: 1005:    __table_.__rehash_unique(__u.bucket_count());
        -: 1006:    insert(__u.begin(), __u.end());
        -: 1007:}
        -: 1008:
        -: 1009:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1010:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1011:        const unordered_set& __u, const allocator_type& __a)
        -: 1012:    : __table_(__u.__table_, __a)
        -: 1013:{
        -: 1014:    _VSTD::__debug_db_insert_c(this);
        -: 1015:    __table_.__rehash_unique(__u.bucket_count());
        -: 1016:    insert(__u.begin(), __u.end());
        -: 1017:}
        -: 1018:
        -: 1019:#ifndef _LIBCPP_CXX03_LANG
        -: 1020:
        -: 1021:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1022:inline
        -: 1023:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1024:        unordered_set&& __u)
        -: 1025:    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
        -: 1026:    : __table_(_VSTD::move(__u.__table_))
        -: 1027:{
        -: 1028:    _VSTD::__debug_db_insert_c(this);
        -: 1029:    std::__debug_db_swap(this, std::addressof(__u));
        -: 1030:}
        -: 1031:
        -: 1032:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1033:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1034:        unordered_set&& __u, const allocator_type& __a)
        -: 1035:    : __table_(_VSTD::move(__u.__table_), __a)
        -: 1036:{
        -: 1037:    _VSTD::__debug_db_insert_c(this);
        -: 1038:    if (__a != __u.get_allocator())
        -: 1039:    {
        -: 1040:        iterator __i = __u.begin();
        -: 1041:        while (__u.size() != 0)
        -: 1042:            __table_.__insert_unique(_VSTD::move(__u.__table_.remove(__i++)->__value_));
        -: 1043:    }
        -: 1044:    else
        -: 1045:        std::__debug_db_swap(this, std::addressof(__u));
        -: 1046:}
        -: 1047:
        -: 1048:template <class _Value, class _Hash, class _Pred, class _Alloc>
function _ZNSt3__113unordered_setIP5GraphNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEEC1ESt16initializer_listIS2_E called 1 returned 100% blocks executed 100%
function _ZNSt3__113unordered_setIP5GraphNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEEC2ESt16initializer_listIS2_E called 1 returned 100% blocks executed 60%
        2: 1049:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1050:        initializer_list<value_type> __il)
        1: 1051:{
        1: 1052:    _VSTD::__debug_db_insert_c(this);
        1: 1052-block  0
branch  0 taken 1
branch  1 taken 0
        1: 1053:    insert(__il.begin(), __il.end());
        1: 1053-block  0
branch  0 taken 1
branch  1 taken 0
        2: 1054:}
        1: 1054-block  0
        1: 1054-block  1
    $$$$$: 1054-block  2
    $$$$$: 1054-block  3
        -: 1055:
        -: 1056:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1057:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1058:        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        -: 1059:        const key_equal& __eql)
        -: 1060:    : __table_(__hf, __eql)
        -: 1061:{
        -: 1062:    _VSTD::__debug_db_insert_c(this);
        -: 1063:    __table_.__rehash_unique(__n);
        -: 1064:    insert(__il.begin(), __il.end());
        -: 1065:}
        -: 1066:
        -: 1067:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1068:unordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(
        -: 1069:        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        -: 1070:        const key_equal& __eql, const allocator_type& __a)
        -: 1071:    : __table_(__hf, __eql, __a)
        -: 1072:{
        -: 1073:    _VSTD::__debug_db_insert_c(this);
        -: 1074:    __table_.__rehash_unique(__n);
        -: 1075:    insert(__il.begin(), __il.end());
        -: 1076:}
        -: 1077:
        -: 1078:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1079:inline
        -: 1080:unordered_set<_Value, _Hash, _Pred, _Alloc>&
        -: 1081:unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)
        -: 1082:    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)
        -: 1083:{
        -: 1084:    __table_ = _VSTD::move(__u.__table_);
        -: 1085:    return *this;
        -: 1086:}
        -: 1087:
        -: 1088:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1089:inline
        -: 1090:unordered_set<_Value, _Hash, _Pred, _Alloc>&
        -: 1091:unordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(
        -: 1092:        initializer_list<value_type> __il)
        -: 1093:{
        -: 1094:    __table_.__assign_unique(__il.begin(), __il.end());
        -: 1095:    return *this;
        -: 1096:}
        -: 1097:
        -: 1098:#endif // _LIBCPP_CXX03_LANG
        -: 1099:
        -: 1100:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1101:template <class _InputIterator>
        -: 1102:inline
        -: 1103:void
function _ZNSt3__113unordered_setIP5GraphNS_4hashIS2_EENS_8equal_toIS2_EENS_9allocatorIS2_EEE6insertIPKS2_EEvT_SD_ called 1 returned 100% blocks executed 100%
        1: 1104:unordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
        -: 1105:                                                    _InputIterator __last)
        -: 1106:{
        2: 1107:    for (; __first != __last; ++__first)
        1: 1107-block  0
        2: 1107-block  1
branch  0 taken 1
branch  1 taken 1
        1: 1107-block  2
        1: 1108:        __table_.__insert_unique(*__first);
        1: 1108-block  0
        1: 1109:}
        1: 1109-block  0
        -: 1110:
        -: 1111:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1112:inline _LIBCPP_INLINE_VISIBILITY
        -: 1113:void
        -: 1114:swap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1115:     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1116:    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))
        -: 1117:{
        -: 1118:    __x.swap(__y);
        -: 1119:}
        -: 1120:
        -: 1121:#if _LIBCPP_STD_VER > 17
        -: 1122:template <class _Value, class _Hash, class _Pred, class _Alloc,
        -: 1123:          class _Predicate>
        -: 1124:inline _LIBCPP_INLINE_VISIBILITY
        -: 1125:    typename unordered_set<_Value, _Hash, _Pred, _Alloc>::size_type
        -: 1126:    erase_if(unordered_set<_Value, _Hash, _Pred, _Alloc>& __c,
        -: 1127:             _Predicate __pred) {
        -: 1128:  return _VSTD::__libcpp_erase_if_container(__c, __pred);
        -: 1129:}
        -: 1130:#endif
        -: 1131:
        -: 1132:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1133:bool
        -: 1134:operator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1135:           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1136:{
        -: 1137:    if (__x.size() != __y.size())
        -: 1138:        return false;
        -: 1139:    typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator
        -: 1140:                                                                 const_iterator;
        -: 1141:    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();
        -: 1142:            __i != __ex; ++__i)
        -: 1143:    {
        -: 1144:        const_iterator __j = __y.find(*__i);
        -: 1145:        if (__j == __ey || !(*__i == *__j))
        -: 1146:            return false;
        -: 1147:    }
        -: 1148:    return true;
        -: 1149:}
        -: 1150:
        -: 1151:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1152:inline _LIBCPP_INLINE_VISIBILITY
        -: 1153:bool
        -: 1154:operator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1155:           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1156:{
        -: 1157:    return !(__x == __y);
        -: 1158:}
        -: 1159:
        -: 1160:template <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,
        -: 1161:          class _Alloc = allocator<_Value> >
        -: 1162:class _LIBCPP_TEMPLATE_VIS unordered_multiset
        -: 1163:{
        -: 1164:public:
        -: 1165:    // types
        -: 1166:    typedef _Value                                                     key_type;
        -: 1167:    typedef key_type                                                   value_type;
        -: 1168:    typedef __type_identity_t<_Hash>                                   hasher;
        -: 1169:    typedef __type_identity_t<_Pred>                                   key_equal;
        -: 1170:    typedef __type_identity_t<_Alloc>                                  allocator_type;
        -: 1171:    typedef value_type&                                                reference;
        -: 1172:    typedef const value_type&                                          const_reference;
        -: 1173:    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
        -: 1174:                  "Invalid allocator::value_type");
        -: 1175:
        -: 1176:private:
        -: 1177:    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;
        -: 1178:
        -: 1179:    __table __table_;
        -: 1180:
        -: 1181:public:
        -: 1182:    typedef typename __table::pointer         pointer;
        -: 1183:    typedef typename __table::const_pointer   const_pointer;
        -: 1184:    typedef typename __table::size_type       size_type;
        -: 1185:    typedef typename __table::difference_type difference_type;
        -: 1186:
        -: 1187:    typedef typename __table::const_iterator       iterator;
        -: 1188:    typedef typename __table::const_iterator       const_iterator;
        -: 1189:    typedef typename __table::const_local_iterator local_iterator;
        -: 1190:    typedef typename __table::const_local_iterator const_local_iterator;
        -: 1191:
        -: 1192:#if _LIBCPP_STD_VER > 14
        -: 1193:    typedef __set_node_handle<typename __table::__node, allocator_type> node_type;
        -: 1194:#endif
        -: 1195:
        -: 1196:    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1197:        friend class _LIBCPP_TEMPLATE_VIS unordered_set;
        -: 1198:    template <class _Value2, class _Hash2, class _Pred2, class _Alloc2>
        -: 1199:        friend class _LIBCPP_TEMPLATE_VIS unordered_multiset;
        -: 1200:
        -: 1201:    _LIBCPP_INLINE_VISIBILITY
        -: 1202:    unordered_multiset()
        -: 1203:        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)
        -: 1204:    {
        -: 1205:        _VSTD::__debug_db_insert_c(this);
        -: 1206:    }
        -: 1207:    explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),
        -: 1208:                                const key_equal& __eql = key_equal());
        -: 1209:    unordered_multiset(size_type __n, const hasher& __hf,
        -: 1210:                       const key_equal& __eql, const allocator_type& __a);
        -: 1211:#if _LIBCPP_STD_VER > 11
        -: 1212:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1213:    unordered_multiset(size_type __n, const allocator_type& __a)
        -: 1214:        : unordered_multiset(__n, hasher(), key_equal(), __a) {}
        -: 1215:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1216:    unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1217:        : unordered_multiset(__n, __hf, key_equal(), __a) {}
        -: 1218:#endif
        -: 1219:    template <class _InputIterator>
        -: 1220:        unordered_multiset(_InputIterator __first, _InputIterator __last);
        -: 1221:    template <class _InputIterator>
        -: 1222:        unordered_multiset(_InputIterator __first, _InputIterator __last,
        -: 1223:                      size_type __n, const hasher& __hf = hasher(),
        -: 1224:                      const key_equal& __eql = key_equal());
        -: 1225:    template <class _InputIterator>
        -: 1226:        unordered_multiset(_InputIterator __first, _InputIterator __last,
        -: 1227:                      size_type __n , const hasher& __hf,
        -: 1228:                      const key_equal& __eql, const allocator_type& __a);
        -: 1229:#if _LIBCPP_STD_VER > 11
        -: 1230:    template <class _InputIterator>
        -: 1231:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1232:    unordered_multiset(_InputIterator __first, _InputIterator __last,
        -: 1233:                       size_type __n, const allocator_type& __a)
        -: 1234:        : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}
        -: 1235:    template <class _InputIterator>
        -: 1236:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1237:    unordered_multiset(_InputIterator __first, _InputIterator __last,
        -: 1238:                       size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1239:        : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}
        -: 1240:#endif
        -: 1241:    _LIBCPP_INLINE_VISIBILITY
        -: 1242:    explicit unordered_multiset(const allocator_type& __a);
        -: 1243:    unordered_multiset(const unordered_multiset& __u);
        -: 1244:    unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);
        -: 1245:#ifndef _LIBCPP_CXX03_LANG
        -: 1246:    _LIBCPP_INLINE_VISIBILITY
        -: 1247:    unordered_multiset(unordered_multiset&& __u)
        -: 1248:        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);
        -: 1249:    unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);
        -: 1250:    unordered_multiset(initializer_list<value_type> __il);
        -: 1251:    unordered_multiset(initializer_list<value_type> __il, size_type __n,
        -: 1252:                       const hasher& __hf = hasher(),
        -: 1253:                       const key_equal& __eql = key_equal());
        -: 1254:    unordered_multiset(initializer_list<value_type> __il, size_type __n,
        -: 1255:                       const hasher& __hf, const key_equal& __eql,
        -: 1256:                       const allocator_type& __a);
        -: 1257:#if _LIBCPP_STD_VER > 11
        -: 1258:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1259:    unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)
        -: 1260:      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}
        -: 1261:    inline _LIBCPP_INLINE_VISIBILITY
        -: 1262:    unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)
        -: 1263:      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}
        -: 1264:#endif
        -: 1265:#endif // _LIBCPP_CXX03_LANG
        -: 1266:    _LIBCPP_INLINE_VISIBILITY
        -: 1267:    ~unordered_multiset() {
        -: 1268:        static_assert(sizeof(__diagnose_unordered_container_requirements<_Value, _Hash, _Pred>(0)), "");
        -: 1269:    }
        -: 1270:
        -: 1271:    _LIBCPP_INLINE_VISIBILITY
        -: 1272:    unordered_multiset& operator=(const unordered_multiset& __u)
        -: 1273:    {
        -: 1274:        __table_ = __u.__table_;
        -: 1275:        return *this;
        -: 1276:    }
        -: 1277:#ifndef _LIBCPP_CXX03_LANG
        -: 1278:    _LIBCPP_INLINE_VISIBILITY
        -: 1279:    unordered_multiset& operator=(unordered_multiset&& __u)
        -: 1280:        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);
        -: 1281:    unordered_multiset& operator=(initializer_list<value_type> __il);
        -: 1282:#endif // _LIBCPP_CXX03_LANG
        -: 1283:
        -: 1284:    _LIBCPP_INLINE_VISIBILITY
        -: 1285:    allocator_type get_allocator() const _NOEXCEPT
        -: 1286:        {return allocator_type(__table_.__node_alloc());}
        -: 1287:
        -: 1288:    _LIBCPP_NODISCARD_AFTER_CXX17 _LIBCPP_INLINE_VISIBILITY
        -: 1289:    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}
        -: 1290:    _LIBCPP_INLINE_VISIBILITY
        -: 1291:    size_type size() const _NOEXCEPT  {return __table_.size();}
        -: 1292:    _LIBCPP_INLINE_VISIBILITY
        -: 1293:    size_type max_size() const _NOEXCEPT {return __table_.max_size();}
        -: 1294:
        -: 1295:    _LIBCPP_INLINE_VISIBILITY
        -: 1296:    iterator       begin() _NOEXCEPT        {return __table_.begin();}
        -: 1297:    _LIBCPP_INLINE_VISIBILITY
        -: 1298:    iterator       end() _NOEXCEPT          {return __table_.end();}
        -: 1299:    _LIBCPP_INLINE_VISIBILITY
        -: 1300:    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}
        -: 1301:    _LIBCPP_INLINE_VISIBILITY
        -: 1302:    const_iterator end()    const _NOEXCEPT {return __table_.end();}
        -: 1303:    _LIBCPP_INLINE_VISIBILITY
        -: 1304:    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}
        -: 1305:    _LIBCPP_INLINE_VISIBILITY
        -: 1306:    const_iterator cend()   const _NOEXCEPT {return __table_.end();}
        -: 1307:
        -: 1308:#ifndef _LIBCPP_CXX03_LANG
        -: 1309:    template <class... _Args>
        -: 1310:        _LIBCPP_INLINE_VISIBILITY
        -: 1311:        iterator emplace(_Args&&... __args)
        -: 1312:            {return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}
        -: 1313:    template <class... _Args>
        -: 1314:        _LIBCPP_INLINE_VISIBILITY
        -: 1315:        iterator emplace_hint(const_iterator __p, _Args&&... __args)
        -: 1316:            {return __table_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}
        -: 1317:
        -: 1318:    _LIBCPP_INLINE_VISIBILITY
        -: 1319:    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}
        -: 1320:    _LIBCPP_INLINE_VISIBILITY
        -: 1321:    iterator insert(const_iterator __p, value_type&& __x)
        -: 1322:        {return __table_.__insert_multi(__p, _VSTD::move(__x));}
        -: 1323:    _LIBCPP_INLINE_VISIBILITY
        -: 1324:    void insert(initializer_list<value_type> __il)
        -: 1325:        {insert(__il.begin(), __il.end());}
        -: 1326:#endif // _LIBCPP_CXX03_LANG
        -: 1327:
        -: 1328:    _LIBCPP_INLINE_VISIBILITY
        -: 1329:    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}
        -: 1330:
        -: 1331:    _LIBCPP_INLINE_VISIBILITY
        -: 1332:    iterator insert(const_iterator __p, const value_type& __x)
        -: 1333:        {return __table_.__insert_multi(__p, __x);}
        -: 1334:
        -: 1335:    template <class _InputIterator>
        -: 1336:        _LIBCPP_INLINE_VISIBILITY
        -: 1337:        void insert(_InputIterator __first, _InputIterator __last);
        -: 1338:
        -: 1339:#if _LIBCPP_STD_VER > 14
        -: 1340:    _LIBCPP_INLINE_VISIBILITY
        -: 1341:    iterator insert(node_type&& __nh)
        -: 1342:    {
        -: 1343:        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 1344:            "node_type with incompatible allocator passed to unordered_multiset::insert()");
        -: 1345:        return __table_.template __node_handle_insert_multi<node_type>(
        -: 1346:            _VSTD::move(__nh));
        -: 1347:    }
        -: 1348:    _LIBCPP_INLINE_VISIBILITY
        -: 1349:    iterator insert(const_iterator __hint, node_type&& __nh)
        -: 1350:    {
        -: 1351:        _LIBCPP_ASSERT(__nh.empty() || __nh.get_allocator() == get_allocator(),
        -: 1352:            "node_type with incompatible allocator passed to unordered_multiset::insert()");
        -: 1353:        return __table_.template __node_handle_insert_multi<node_type>(
        -: 1354:            __hint, _VSTD::move(__nh));
        -: 1355:    }
        -: 1356:    _LIBCPP_INLINE_VISIBILITY
        -: 1357:    node_type extract(const_iterator __position)
        -: 1358:    {
        -: 1359:        return __table_.template __node_handle_extract<node_type>(
        -: 1360:            __position);
        -: 1361:    }
        -: 1362:    _LIBCPP_INLINE_VISIBILITY
        -: 1363:    node_type extract(key_type const& __key)
        -: 1364:    {
        -: 1365:        return __table_.template __node_handle_extract<node_type>(__key);
        -: 1366:    }
        -: 1367:
        -: 1368:    template <class _H2, class _P2>
        -: 1369:    _LIBCPP_INLINE_VISIBILITY
        -: 1370:    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>& __source)
        -: 1371:    {
        -: 1372:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -: 1373:                       "merging container with incompatible allocator");
        -: 1374:        return __table_.__node_handle_merge_multi(__source.__table_);
        -: 1375:    }
        -: 1376:    template <class _H2, class _P2>
        -: 1377:    _LIBCPP_INLINE_VISIBILITY
        -: 1378:    void merge(unordered_multiset<key_type, _H2, _P2, allocator_type>&& __source)
        -: 1379:    {
        -: 1380:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -: 1381:                       "merging container with incompatible allocator");
        -: 1382:        return __table_.__node_handle_merge_multi(__source.__table_);
        -: 1383:    }
        -: 1384:    template <class _H2, class _P2>
        -: 1385:    _LIBCPP_INLINE_VISIBILITY
        -: 1386:    void merge(unordered_set<key_type, _H2, _P2, allocator_type>& __source)
        -: 1387:    {
        -: 1388:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -: 1389:                       "merging container with incompatible allocator");
        -: 1390:        return __table_.__node_handle_merge_multi(__source.__table_);
        -: 1391:    }
        -: 1392:    template <class _H2, class _P2>
        -: 1393:    _LIBCPP_INLINE_VISIBILITY
        -: 1394:    void merge(unordered_set<key_type, _H2, _P2, allocator_type>&& __source)
        -: 1395:    {
        -: 1396:        _LIBCPP_ASSERT(__source.get_allocator() == get_allocator(),
        -: 1397:                       "merging container with incompatible allocator");
        -: 1398:        return __table_.__node_handle_merge_multi(__source.__table_);
        -: 1399:    }
        -: 1400:#endif
        -: 1401:
        -: 1402:    _LIBCPP_INLINE_VISIBILITY
        -: 1403:    iterator erase(const_iterator __p) {return __table_.erase(__p);}
        -: 1404:    _LIBCPP_INLINE_VISIBILITY
        -: 1405:    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}
        -: 1406:    _LIBCPP_INLINE_VISIBILITY
        -: 1407:    iterator erase(const_iterator __first, const_iterator __last)
        -: 1408:        {return __table_.erase(__first, __last);}
        -: 1409:    _LIBCPP_INLINE_VISIBILITY
        -: 1410:    void clear() _NOEXCEPT {__table_.clear();}
        -: 1411:
        -: 1412:    _LIBCPP_INLINE_VISIBILITY
        -: 1413:    void swap(unordered_multiset& __u)
        -: 1414:        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)
        -: 1415:        {__table_.swap(__u.__table_);}
        -: 1416:
        -: 1417:    _LIBCPP_INLINE_VISIBILITY
        -: 1418:    hasher hash_function() const {return __table_.hash_function();}
        -: 1419:    _LIBCPP_INLINE_VISIBILITY
        -: 1420:    key_equal key_eq() const {return __table_.key_eq();}
        -: 1421:
        -: 1422:    _LIBCPP_INLINE_VISIBILITY
        -: 1423:    iterator       find(const key_type& __k)       {return __table_.find(__k);}
        -: 1424:    _LIBCPP_INLINE_VISIBILITY
        -: 1425:    const_iterator find(const key_type& __k) const {return __table_.find(__k);}
        -: 1426:#if _LIBCPP_STD_VER > 17
        -: 1427:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1428:    _LIBCPP_INLINE_VISIBILITY
        -: 1429:    iterator       find(const _K2& __k)            {return __table_.find(__k);}
        -: 1430:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1431:    _LIBCPP_INLINE_VISIBILITY
        -: 1432:    const_iterator find(const _K2& __k) const      {return __table_.find(__k);}
        -: 1433:#endif // _LIBCPP_STD_VER > 17
        -: 1434:
        -: 1435:    _LIBCPP_INLINE_VISIBILITY
        -: 1436:    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}
        -: 1437:#if _LIBCPP_STD_VER > 17
        -: 1438:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1439:    _LIBCPP_INLINE_VISIBILITY
        -: 1440:    size_type count(const _K2& __k) const      {return __table_.__count_multi(__k);}
        -: 1441:#endif // _LIBCPP_STD_VER > 17
        -: 1442:
        -: 1443:#if _LIBCPP_STD_VER > 17
        -: 1444:    _LIBCPP_INLINE_VISIBILITY
        -: 1445:    bool contains(const key_type& __k) const {return find(__k) != end();}
        -: 1446:
        -: 1447:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1448:    _LIBCPP_INLINE_VISIBILITY
        -: 1449:    bool contains(const _K2& __k) const      {return find(__k) != end();}
        -: 1450:#endif // _LIBCPP_STD_VER > 17
        -: 1451:
        -: 1452:    _LIBCPP_INLINE_VISIBILITY
        -: 1453:    pair<iterator, iterator>             equal_range(const key_type& __k)
        -: 1454:        {return __table_.__equal_range_multi(__k);}
        -: 1455:    _LIBCPP_INLINE_VISIBILITY
        -: 1456:    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const
        -: 1457:        {return __table_.__equal_range_multi(__k);}
        -: 1458:#if _LIBCPP_STD_VER > 17
        -: 1459:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1460:    _LIBCPP_INLINE_VISIBILITY
        -: 1461:    pair<iterator, iterator>             equal_range(const _K2& __k)
        -: 1462:        {return __table_.__equal_range_multi(__k);}
        -: 1463:    template<class _K2, enable_if_t<__is_transparent<hasher, _K2>::value && __is_transparent<key_equal, _K2>::value>* = nullptr>
        -: 1464:    _LIBCPP_INLINE_VISIBILITY
        -: 1465:    pair<const_iterator, const_iterator> equal_range(const _K2& __k) const
        -: 1466:        {return __table_.__equal_range_multi(__k);}
        -: 1467:#endif // _LIBCPP_STD_VER > 17
        -: 1468:
        -: 1469:    _LIBCPP_INLINE_VISIBILITY
        -: 1470:    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}
        -: 1471:    _LIBCPP_INLINE_VISIBILITY
        -: 1472:    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}
        -: 1473:
        -: 1474:    _LIBCPP_INLINE_VISIBILITY
        -: 1475:    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}
        -: 1476:    _LIBCPP_INLINE_VISIBILITY
        -: 1477:    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}
        -: 1478:
        -: 1479:    _LIBCPP_INLINE_VISIBILITY
        -: 1480:    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}
        -: 1481:    _LIBCPP_INLINE_VISIBILITY
        -: 1482:    local_iterator       end(size_type __n)          {return __table_.end(__n);}
        -: 1483:    _LIBCPP_INLINE_VISIBILITY
        -: 1484:    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}
        -: 1485:    _LIBCPP_INLINE_VISIBILITY
        -: 1486:    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}
        -: 1487:    _LIBCPP_INLINE_VISIBILITY
        -: 1488:    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}
        -: 1489:    _LIBCPP_INLINE_VISIBILITY
        -: 1490:    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}
        -: 1491:
        -: 1492:    _LIBCPP_INLINE_VISIBILITY
        -: 1493:    float load_factor() const _NOEXCEPT {return __table_.load_factor();}
        -: 1494:    _LIBCPP_INLINE_VISIBILITY
        -: 1495:    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}
        -: 1496:    _LIBCPP_INLINE_VISIBILITY
        -: 1497:    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}
        -: 1498:    _LIBCPP_INLINE_VISIBILITY
        -: 1499:    void rehash(size_type __n) {__table_.__rehash_multi(__n);}
        -: 1500:    _LIBCPP_INLINE_VISIBILITY
        -: 1501:    void reserve(size_type __n) {__table_.__reserve_multi(__n);}
        -: 1502:
        -: 1503:#ifdef _LIBCPP_ENABLE_DEBUG_MODE
        -: 1504:
        -: 1505:    bool __dereferenceable(const const_iterator* __i) const
        -: 1506:        {return __table_.__dereferenceable(__i);}
        -: 1507:    bool __decrementable(const const_iterator* __i) const
        -: 1508:        {return __table_.__decrementable(__i);}
        -: 1509:    bool __addable(const const_iterator* __i, ptrdiff_t __n) const
        -: 1510:        {return __table_.__addable(__i, __n);}
        -: 1511:    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const
        -: 1512:        {return __table_.__addable(__i, __n);}
        -: 1513:
        -: 1514:#endif // _LIBCPP_ENABLE_DEBUG_MODE
        -: 1515:
        -: 1516:};
        -: 1517:
        -: 1518:#if _LIBCPP_STD_VER >= 17
        -: 1519:template<class _InputIterator,
        -: 1520:         class _Hash = hash<__iter_value_type<_InputIterator>>,
        -: 1521:         class _Pred = equal_to<__iter_value_type<_InputIterator>>,
        -: 1522:         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
        -: 1523:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -: 1524:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1525:         class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1526:         class = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 1527:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1528:unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type = 0,
        -: 1529:              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
        -: 1530:  -> unordered_multiset<__iter_value_type<_InputIterator>, _Hash, _Pred, _Allocator>;
        -: 1531:
        -: 1532:template<class _Tp, class _Hash = hash<_Tp>,
        -: 1533:         class _Pred = equal_to<_Tp>, class _Allocator = allocator<_Tp>,
        -: 1534:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1535:         class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1536:         class = enable_if_t<!__is_allocator<_Pred>::value>,
        -: 1537:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1538:unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type = 0,
        -: 1539:              _Hash = _Hash(), _Pred = _Pred(), _Allocator = _Allocator())
        -: 1540:  -> unordered_multiset<_Tp, _Hash, _Pred, _Allocator>;
        -: 1541:
        -: 1542:template<class _InputIterator, class _Allocator,
        -: 1543:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -: 1544:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1545:unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 1546:  -> unordered_multiset<__iter_value_type<_InputIterator>,
        -: 1547:                   hash<__iter_value_type<_InputIterator>>,
        -: 1548:                   equal_to<__iter_value_type<_InputIterator>>,
        -: 1549:                   _Allocator>;
        -: 1550:
        -: 1551:template<class _InputIterator, class _Hash, class _Allocator,
        -: 1552:         class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
        -: 1553:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1554:         class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1555:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1556:unordered_multiset(_InputIterator, _InputIterator, typename allocator_traits<_Allocator>::size_type,
        -: 1557:              _Hash, _Allocator)
        -: 1558:  -> unordered_multiset<__iter_value_type<_InputIterator>, _Hash,
        -: 1559:                   equal_to<__iter_value_type<_InputIterator>>,
        -: 1560:                   _Allocator>;
        -: 1561:
        -: 1562:template<class _Tp, class _Allocator,
        -: 1563:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1564:unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Allocator)
        -: 1565:  -> unordered_multiset<_Tp, hash<_Tp>, equal_to<_Tp>, _Allocator>;
        -: 1566:
        -: 1567:template<class _Tp, class _Hash, class _Allocator,
        -: 1568:         class = enable_if_t<!__is_allocator<_Hash>::value>,
        -: 1569:         class = enable_if_t<!is_integral<_Hash>::value>,
        -: 1570:         class = enable_if_t<__is_allocator<_Allocator>::value>>
        -: 1571:unordered_multiset(initializer_list<_Tp>, typename allocator_traits<_Allocator>::size_type, _Hash, _Allocator)
        -: 1572:  -> unordered_multiset<_Tp, _Hash, equal_to<_Tp>, _Allocator>;
        -: 1573:#endif
        -: 1574:
        -: 1575:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1576:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1577:        size_type __n, const hasher& __hf, const key_equal& __eql)
        -: 1578:    : __table_(__hf, __eql)
        -: 1579:{
        -: 1580:    _VSTD::__debug_db_insert_c(this);
        -: 1581:    __table_.__rehash_multi(__n);
        -: 1582:}
        -: 1583:
        -: 1584:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1585:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1586:        size_type __n, const hasher& __hf, const key_equal& __eql,
        -: 1587:        const allocator_type& __a)
        -: 1588:    : __table_(__hf, __eql, __a)
        -: 1589:{
        -: 1590:    _VSTD::__debug_db_insert_c(this);
        -: 1591:    __table_.__rehash_multi(__n);
        -: 1592:}
        -: 1593:
        -: 1594:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1595:template <class _InputIterator>
        -: 1596:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1597:        _InputIterator __first, _InputIterator __last)
        -: 1598:{
        -: 1599:    _VSTD::__debug_db_insert_c(this);
        -: 1600:    insert(__first, __last);
        -: 1601:}
        -: 1602:
        -: 1603:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1604:template <class _InputIterator>
        -: 1605:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1606:        _InputIterator __first, _InputIterator __last, size_type __n,
        -: 1607:        const hasher& __hf, const key_equal& __eql)
        -: 1608:    : __table_(__hf, __eql)
        -: 1609:{
        -: 1610:    _VSTD::__debug_db_insert_c(this);
        -: 1611:    __table_.__rehash_multi(__n);
        -: 1612:    insert(__first, __last);
        -: 1613:}
        -: 1614:
        -: 1615:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1616:template <class _InputIterator>
        -: 1617:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1618:        _InputIterator __first, _InputIterator __last, size_type __n,
        -: 1619:        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)
        -: 1620:    : __table_(__hf, __eql, __a)
        -: 1621:{
        -: 1622:    _VSTD::__debug_db_insert_c(this);
        -: 1623:    __table_.__rehash_multi(__n);
        -: 1624:    insert(__first, __last);
        -: 1625:}
        -: 1626:
        -: 1627:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1628:inline
        -: 1629:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1630:        const allocator_type& __a)
        -: 1631:    : __table_(__a)
        -: 1632:{
        -: 1633:    _VSTD::__debug_db_insert_c(this);
        -: 1634:}
        -: 1635:
        -: 1636:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1637:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1638:        const unordered_multiset& __u)
        -: 1639:    : __table_(__u.__table_)
        -: 1640:{
        -: 1641:    _VSTD::__debug_db_insert_c(this);
        -: 1642:    __table_.__rehash_multi(__u.bucket_count());
        -: 1643:    insert(__u.begin(), __u.end());
        -: 1644:}
        -: 1645:
        -: 1646:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1647:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1648:        const unordered_multiset& __u, const allocator_type& __a)
        -: 1649:    : __table_(__u.__table_, __a)
        -: 1650:{
        -: 1651:    _VSTD::__debug_db_insert_c(this);
        -: 1652:    __table_.__rehash_multi(__u.bucket_count());
        -: 1653:    insert(__u.begin(), __u.end());
        -: 1654:}
        -: 1655:
        -: 1656:#ifndef _LIBCPP_CXX03_LANG
        -: 1657:
        -: 1658:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1659:inline
        -: 1660:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1661:        unordered_multiset&& __u)
        -: 1662:    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)
        -: 1663:    : __table_(_VSTD::move(__u.__table_))
        -: 1664:{
        -: 1665:    _VSTD::__debug_db_insert_c(this);
        -: 1666:    std::__debug_db_swap(this, std::addressof(__u));
        -: 1667:}
        -: 1668:
        -: 1669:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1670:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1671:        unordered_multiset&& __u, const allocator_type& __a)
        -: 1672:    : __table_(_VSTD::move(__u.__table_), __a)
        -: 1673:{
        -: 1674:    _VSTD::__debug_db_insert_c(this);
        -: 1675:    if (__a != __u.get_allocator())
        -: 1676:    {
        -: 1677:        iterator __i = __u.begin();
        -: 1678:        while (__u.size() != 0)
        -: 1679:            __table_.__insert_multi(_VSTD::move(__u.__table_.remove(__i++)->__value_));
        -: 1680:    }
        -: 1681:    else
        -: 1682:        std::__debug_db_swap(this, std::addressof(__u));
        -: 1683:}
        -: 1684:
        -: 1685:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1686:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1687:        initializer_list<value_type> __il)
        -: 1688:{
        -: 1689:    _VSTD::__debug_db_insert_c(this);
        -: 1690:    insert(__il.begin(), __il.end());
        -: 1691:}
        -: 1692:
        -: 1693:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1694:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1695:        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        -: 1696:        const key_equal& __eql)
        -: 1697:    : __table_(__hf, __eql)
        -: 1698:{
        -: 1699:    _VSTD::__debug_db_insert_c(this);
        -: 1700:    __table_.__rehash_multi(__n);
        -: 1701:    insert(__il.begin(), __il.end());
        -: 1702:}
        -: 1703:
        -: 1704:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1705:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(
        -: 1706:        initializer_list<value_type> __il, size_type __n, const hasher& __hf,
        -: 1707:        const key_equal& __eql, const allocator_type& __a)
        -: 1708:    : __table_(__hf, __eql, __a)
        -: 1709:{
        -: 1710:    _VSTD::__debug_db_insert_c(this);
        -: 1711:    __table_.__rehash_multi(__n);
        -: 1712:    insert(__il.begin(), __il.end());
        -: 1713:}
        -: 1714:
        -: 1715:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1716:inline
        -: 1717:unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
        -: 1718:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        -: 1719:        unordered_multiset&& __u)
        -: 1720:    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)
        -: 1721:{
        -: 1722:    __table_ = _VSTD::move(__u.__table_);
        -: 1723:    return *this;
        -: 1724:}
        -: 1725:
        -: 1726:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1727:inline
        -: 1728:unordered_multiset<_Value, _Hash, _Pred, _Alloc>&
        -: 1729:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(
        -: 1730:        initializer_list<value_type> __il)
        -: 1731:{
        -: 1732:    __table_.__assign_multi(__il.begin(), __il.end());
        -: 1733:    return *this;
        -: 1734:}
        -: 1735:
        -: 1736:#endif // _LIBCPP_CXX03_LANG
        -: 1737:
        -: 1738:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1739:template <class _InputIterator>
        -: 1740:inline
        -: 1741:void
        -: 1742:unordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,
        -: 1743:                                                         _InputIterator __last)
        -: 1744:{
        -: 1745:    for (; __first != __last; ++__first)
        -: 1746:        __table_.__insert_multi(*__first);
        -: 1747:}
        -: 1748:
        -: 1749:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1750:inline _LIBCPP_INLINE_VISIBILITY
        -: 1751:void
        -: 1752:swap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1753:     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1754:    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))
        -: 1755:{
        -: 1756:    __x.swap(__y);
        -: 1757:}
        -: 1758:
        -: 1759:#if _LIBCPP_STD_VER > 17
        -: 1760:template <class _Value, class _Hash, class _Pred, class _Alloc,
        -: 1761:          class _Predicate>
        -: 1762:inline _LIBCPP_INLINE_VISIBILITY
        -: 1763:    typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::size_type
        -: 1764:    erase_if(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __c,
        -: 1765:             _Predicate __pred) {
        -: 1766:  return _VSTD::__libcpp_erase_if_container(__c, __pred);
        -: 1767:}
        -: 1768:#endif
        -: 1769:
        -: 1770:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1771:bool
        -: 1772:operator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1773:           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1774:{
        -: 1775:    if (__x.size() != __y.size())
        -: 1776:        return false;
        -: 1777:    typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator
        -: 1778:                                                                 const_iterator;
        -: 1779:    typedef pair<const_iterator, const_iterator> _EqRng;
        -: 1780:    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)
        -: 1781:    {
        -: 1782:        _EqRng __xeq = __x.equal_range(*__i);
        -: 1783:        _EqRng __yeq = __y.equal_range(*__i);
        -: 1784:        if (_VSTD::distance(__xeq.first, __xeq.second) !=
        -: 1785:            _VSTD::distance(__yeq.first, __yeq.second) ||
        -: 1786:                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))
        -: 1787:            return false;
        -: 1788:        __i = __xeq.second;
        -: 1789:    }
        -: 1790:    return true;
        -: 1791:}
        -: 1792:
        -: 1793:template <class _Value, class _Hash, class _Pred, class _Alloc>
        -: 1794:inline _LIBCPP_INLINE_VISIBILITY
        -: 1795:bool
        -: 1796:operator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,
        -: 1797:           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)
        -: 1798:{
        -: 1799:    return !(__x == __y);
        -: 1800:}
        -: 1801:
        -: 1802:_LIBCPP_END_NAMESPACE_STD
        -: 1803:
        -: 1804:#endif // _LIBCPP_UNORDERED_SET
