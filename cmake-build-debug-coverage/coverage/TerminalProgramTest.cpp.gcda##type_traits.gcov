        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX13.3.sdk/usr/include/c++/v1/type_traits
        -:    0:Graph:/Users/mihaildobroslavski/CLionProjects/CityMapProject/cmake-build-debug-coverage/CMakeFiles/TerminalProgramTest.dir/UnitTesting/TerminalProgramTest.cpp.gcno
        -:    0:Data:/Users/mihaildobroslavski/CLionProjects/CityMapProject/cmake-build-debug-coverage/CMakeFiles/TerminalProgramTest.dir/UnitTesting/TerminalProgramTest.cpp.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TYPE_TRAITS
        -:   11:#define _LIBCPP_TYPE_TRAITS
        -:   12:
        -:   13:/*
        -:   14:    type_traits synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:    // helper class:
        -:   20:    template <class T, T v> struct integral_constant;
        -:   21:    typedef integral_constant<bool, true>  true_type;   // C++11
        -:   22:    typedef integral_constant<bool, false> false_type;  // C++11
        -:   23:
        -:   24:    template <bool B>                                   // C++14
        -:   25:    using bool_constant = integral_constant<bool, B>;   // C++14
        -:   26:    typedef bool_constant<true> true_type;              // C++14
        -:   27:    typedef bool_constant<false> false_type;            // C++14
        -:   28:
        -:   29:    // helper traits
        -:   30:    template <bool, class T = void> struct enable_if;
        -:   31:    template <bool, class T, class F> struct conditional;
        -:   32:
        -:   33:    // Primary classification traits:
        -:   34:    template <class T> struct is_void;
        -:   35:    template <class T> struct is_null_pointer;  // C++14
        -:   36:    template <class T> struct is_integral;
        -:   37:    template <class T> struct is_floating_point;
        -:   38:    template <class T> struct is_array;
        -:   39:    template <class T> struct is_pointer;
        -:   40:    template <class T> struct is_lvalue_reference;
        -:   41:    template <class T> struct is_rvalue_reference;
        -:   42:    template <class T> struct is_member_object_pointer;
        -:   43:    template <class T> struct is_member_function_pointer;
        -:   44:    template <class T> struct is_enum;
        -:   45:    template <class T> struct is_union;
        -:   46:    template <class T> struct is_class;
        -:   47:    template <class T> struct is_function;
        -:   48:
        -:   49:    // Secondary classification traits:
        -:   50:    template <class T> struct is_reference;
        -:   51:    template <class T> struct is_arithmetic;
        -:   52:    template <class T> struct is_fundamental;
        -:   53:    template <class T> struct is_member_pointer;
        -:   54:    template <class T> struct is_scoped_enum; // C++2b
        -:   55:    template <class T> struct is_scalar;
        -:   56:    template <class T> struct is_object;
        -:   57:    template <class T> struct is_compound;
        -:   58:
        -:   59:    // Const-volatile properties and transformations:
        -:   60:    template <class T> struct is_const;
        -:   61:    template <class T> struct is_volatile;
        -:   62:    template <class T> struct remove_const;
        -:   63:    template <class T> struct remove_volatile;
        -:   64:    template <class T> struct remove_cv;
        -:   65:    template <class T> struct add_const;
        -:   66:    template <class T> struct add_volatile;
        -:   67:    template <class T> struct add_cv;
        -:   68:
        -:   69:    // Reference transformations:
        -:   70:    template <class T> struct remove_reference;
        -:   71:    template <class T> struct add_lvalue_reference;
        -:   72:    template <class T> struct add_rvalue_reference;
        -:   73:
        -:   74:    // Pointer transformations:
        -:   75:    template <class T> struct remove_pointer;
        -:   76:    template <class T> struct add_pointer;
        -:   77:
        -:   78:    template<class T> struct type_identity;                     // C++20
        -:   79:    template<class T>
        -:   80:      using type_identity_t = typename type_identity<T>::type;  // C++20
        -:   81:
        -:   82:    // Integral properties:
        -:   83:    template <class T> struct is_signed;
        -:   84:    template <class T> struct is_unsigned;
        -:   85:    template <class T> struct make_signed;
        -:   86:    template <class T> struct make_unsigned;
        -:   87:
        -:   88:    // Array properties and transformations:
        -:   89:    template <class T> struct rank;
        -:   90:    template <class T, unsigned I = 0> struct extent;
        -:   91:    template <class T> struct remove_extent;
        -:   92:    template <class T> struct remove_all_extents;
        -:   93:
        -:   94:    template <class T> struct is_bounded_array;                 // C++20
        -:   95:    template <class T> struct is_unbounded_array;               // C++20
        -:   96:
        -:   97:    // Member introspection:
        -:   98:    template <class T> struct is_pod;
        -:   99:    template <class T> struct is_trivial;
        -:  100:    template <class T> struct is_trivially_copyable;
        -:  101:    template <class T> struct is_standard_layout;
        -:  102:    template <class T> struct is_literal_type; // Deprecated in C++17; removed in C++20
        -:  103:    template <class T> struct is_empty;
        -:  104:    template <class T> struct is_polymorphic;
        -:  105:    template <class T> struct is_abstract;
        -:  106:    template <class T> struct is_final; // C++14
        -:  107:    template <class T> struct is_aggregate; // C++17
        -:  108:
        -:  109:    template <class T, class... Args> struct is_constructible;
        -:  110:    template <class T>                struct is_default_constructible;
        -:  111:    template <class T>                struct is_copy_constructible;
        -:  112:    template <class T>                struct is_move_constructible;
        -:  113:    template <class T, class U>       struct is_assignable;
        -:  114:    template <class T>                struct is_copy_assignable;
        -:  115:    template <class T>                struct is_move_assignable;
        -:  116:    template <class T, class U>       struct is_swappable_with;       // C++17
        -:  117:    template <class T>                struct is_swappable;            // C++17
        -:  118:    template <class T>                struct is_destructible;
        -:  119:
        -:  120:    template <class T, class... Args> struct is_trivially_constructible;
        -:  121:    template <class T>                struct is_trivially_default_constructible;
        -:  122:    template <class T>                struct is_trivially_copy_constructible;
        -:  123:    template <class T>                struct is_trivially_move_constructible;
        -:  124:    template <class T, class U>       struct is_trivially_assignable;
        -:  125:    template <class T>                struct is_trivially_copy_assignable;
        -:  126:    template <class T>                struct is_trivially_move_assignable;
        -:  127:    template <class T>                struct is_trivially_destructible;
        -:  128:
        -:  129:    template <class T, class... Args> struct is_nothrow_constructible;
        -:  130:    template <class T>                struct is_nothrow_default_constructible;
        -:  131:    template <class T>                struct is_nothrow_copy_constructible;
        -:  132:    template <class T>                struct is_nothrow_move_constructible;
        -:  133:    template <class T, class U>       struct is_nothrow_assignable;
        -:  134:    template <class T>                struct is_nothrow_copy_assignable;
        -:  135:    template <class T>                struct is_nothrow_move_assignable;
        -:  136:    template <class T, class U>       struct is_nothrow_swappable_with; // C++17
        -:  137:    template <class T>                struct is_nothrow_swappable;      // C++17
        -:  138:    template <class T>                struct is_nothrow_destructible;
        -:  139:
        -:  140:    template <class T> struct has_virtual_destructor;
        -:  141:
        -:  142:    template<class T> struct has_unique_object_representations;         // C++17
        -:  143:
        -:  144:    // Relationships between types:
        -:  145:    template <class T, class U> struct is_same;
        -:  146:    template <class Base, class Derived> struct is_base_of;
        -:  147:
        -:  148:    template <class From, class To> struct is_convertible;
        -:  149:    template <typename From, typename To> struct is_nothrow_convertible;                  // C++20
        -:  150:    template <typename From, typename To> inline constexpr bool is_nothrow_convertible_v; // C++20
        -:  151:
        -:  152:    template <class Fn, class... ArgTypes> struct is_invocable;
        -:  153:    template <class R, class Fn, class... ArgTypes> struct is_invocable_r;
        -:  154:
        -:  155:    template <class Fn, class... ArgTypes> struct is_nothrow_invocable;
        -:  156:    template <class R, class Fn, class... ArgTypes> struct is_nothrow_invocable_r;
        -:  157:
        -:  158:    // Alignment properties and transformations:
        -:  159:    template <class T> struct alignment_of;
        -:  160:    template <size_t Len, size_t Align = most_stringent_alignment_requirement>
        -:  161:        struct aligned_storage;
        -:  162:    template <size_t Len, class... Types> struct aligned_union;
        -:  163:    template <class T> struct remove_cvref; // C++20
        -:  164:
        -:  165:    template <class T> struct decay;
        -:  166:    template <class... T> struct common_type;
        -:  167:    template <class T> struct underlying_type;
        -:  168:    template <class> class result_of; // undefined; deprecated in C++17; removed in C++20
        -:  169:    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>; // deprecated in C++17; removed in C++20
        -:  170:    template <class Fn, class... ArgTypes> struct invoke_result;  // C++17
        -:  171:
        -:  172:    // const-volatile modifications:
        -:  173:    template <class T>
        -:  174:      using remove_const_t    = typename remove_const<T>::type;  // C++14
        -:  175:    template <class T>
        -:  176:      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14
        -:  177:    template <class T>
        -:  178:      using remove_cv_t       = typename remove_cv<T>::type;  // C++14
        -:  179:    template <class T>
        -:  180:      using add_const_t       = typename add_const<T>::type;  // C++14
        -:  181:    template <class T>
        -:  182:      using add_volatile_t    = typename add_volatile<T>::type;  // C++14
        -:  183:    template <class T>
        -:  184:      using add_cv_t          = typename add_cv<T>::type;  // C++14
        -:  185:
        -:  186:    // reference modifications:
        -:  187:    template <class T>
        -:  188:      using remove_reference_t     = typename remove_reference<T>::type;  // C++14
        -:  189:    template <class T>
        -:  190:      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14
        -:  191:    template <class T>
        -:  192:      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14
        -:  193:
        -:  194:    // sign modifications:
        -:  195:    template <class T>
        -:  196:      using make_signed_t   = typename make_signed<T>::type;  // C++14
        -:  197:    template <class T>
        -:  198:      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14
        -:  199:
        -:  200:    // array modifications:
        -:  201:    template <class T>
        -:  202:      using remove_extent_t      = typename remove_extent<T>::type;  // C++14
        -:  203:    template <class T>
        -:  204:      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14
        -:  205:
        -:  206:    template <class T>
        -:  207:      inline constexpr bool is_bounded_array_v
        -:  208:        = is_bounded_array<T>::value;                                     // C++20
        -:  209:      inline constexpr bool is_unbounded_array_v
        -:  210:        = is_unbounded_array<T>::value;                                   // C++20
        -:  211:
        -:  212:    // pointer modifications:
        -:  213:    template <class T>
        -:  214:      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14
        -:  215:    template <class T>
        -:  216:      using add_pointer_t    = typename add_pointer<T>::type;  // C++14
        -:  217:
        -:  218:    // other transformations:
        -:  219:    template <size_t Len, size_t Align=default-alignment>
        -:  220:      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14
        -:  221:    template <size_t Len, class... Types>
        -:  222:      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14
        -:  223:    template <class T>
        -:  224:      using remove_cvref_t    = typename remove_cvref<T>::type;  // C++20
        -:  225:    template <class T>
        -:  226:      using decay_t           = typename decay<T>::type;  // C++14
        -:  227:    template <bool b, class T=void>
        -:  228:      using enable_if_t       = typename enable_if<b,T>::type;  // C++14
        -:  229:    template <bool b, class T, class F>
        -:  230:      using conditional_t     = typename conditional<b,T,F>::type;  // C++14
        -:  231:    template <class... T>
        -:  232:      using common_type_t     = typename common_type<T...>::type;  // C++14
        -:  233:    template <class T>
        -:  234:      using underlying_type_t = typename underlying_type<T>::type;  // C++14
        -:  235:    template <class T>
        -:  236:      using result_of_t       = typename result_of<T>::type;  // C++14; deprecated in C++17; removed in C++20
        -:  237:    template <class Fn, class... ArgTypes>
        -:  238:      using invoke_result_t   = typename invoke_result<Fn, ArgTypes...>::type;  // C++17
        -:  239:
        -:  240:    template <class...>
        -:  241:      using void_t = void;   // C++17
        -:  242:
        -:  243:      // See C++14 20.10.4.1, primary type categories
        -:  244:      template <class T> inline constexpr bool is_void_v
        -:  245:        = is_void<T>::value;                                             // C++17
        -:  246:      template <class T> inline constexpr bool is_null_pointer_v
        -:  247:        = is_null_pointer<T>::value;                                     // C++17
        -:  248:      template <class T> inline constexpr bool is_integral_v
        -:  249:        = is_integral<T>::value;                                         // C++17
        -:  250:      template <class T> inline constexpr bool is_floating_point_v
        -:  251:        = is_floating_point<T>::value;                                   // C++17
        -:  252:      template <class T> inline constexpr bool is_array_v
        -:  253:        = is_array<T>::value;                                            // C++17
        -:  254:      template <class T> inline constexpr bool is_pointer_v
        -:  255:        = is_pointer<T>::value;                                          // C++17
        -:  256:      template <class T> inline constexpr bool is_lvalue_reference_v
        -:  257:        = is_lvalue_reference<T>::value;                                 // C++17
        -:  258:      template <class T> inline constexpr bool is_rvalue_reference_v
        -:  259:        = is_rvalue_reference<T>::value;                                 // C++17
        -:  260:      template <class T> inline constexpr bool is_member_object_pointer_v
        -:  261:        = is_member_object_pointer<T>::value;                            // C++17
        -:  262:      template <class T> inline constexpr bool is_member_function_pointer_v
        -:  263:        = is_member_function_pointer<T>::value;                          // C++17
        -:  264:      template <class T> inline constexpr bool is_enum_v
        -:  265:        = is_enum<T>::value;                                             // C++17
        -:  266:      template <class T> inline constexpr bool is_union_v
        -:  267:        = is_union<T>::value;                                            // C++17
        -:  268:      template <class T> inline constexpr bool is_class_v
        -:  269:        = is_class<T>::value;                                            // C++17
        -:  270:      template <class T> inline constexpr bool is_function_v
        -:  271:        = is_function<T>::value;                                         // C++17
        -:  272:
        -:  273:      // See C++14 20.10.4.2, composite type categories
        -:  274:      template <class T> inline constexpr bool is_reference_v
        -:  275:        = is_reference<T>::value;                                        // C++17
        -:  276:      template <class T> inline constexpr bool is_arithmetic_v
        -:  277:        = is_arithmetic<T>::value;                                       // C++17
        -:  278:      template <class T> inline constexpr bool is_fundamental_v
        -:  279:        = is_fundamental<T>::value;                                      // C++17
        -:  280:      template <class T> inline constexpr bool is_object_v
        -:  281:        = is_object<T>::value;                                           // C++17
        -:  282:      template <class T> inline constexpr bool is_scalar_v
        -:  283:        = is_scalar<T>::value;                                           // C++17
        -:  284:      template <class T> inline constexpr bool is_compound_v
        -:  285:        = is_compound<T>::value;                                         // C++17
        -:  286:      template <class T> inline constexpr bool is_member_pointer_v
        -:  287:        = is_member_pointer<T>::value;                                   // C++17
        -:  288:      template <class T> inline constexpr bool is_scoped_enum_v
        -:  289:        = is_scoped_enum<T>::value;                                      // C++2b
        -:  290:
        -:  291:      // See C++14 20.10.4.3, type properties
        -:  292:      template <class T> inline constexpr bool is_const_v
        -:  293:        = is_const<T>::value;                                            // C++17
        -:  294:      template <class T> inline constexpr bool is_volatile_v
        -:  295:        = is_volatile<T>::value;                                         // C++17
        -:  296:      template <class T> inline constexpr bool is_trivial_v
        -:  297:        = is_trivial<T>::value;                                          // C++17
        -:  298:      template <class T> inline constexpr bool is_trivially_copyable_v
        -:  299:        = is_trivially_copyable<T>::value;                               // C++17
        -:  300:      template <class T> inline constexpr bool is_standard_layout_v
        -:  301:        = is_standard_layout<T>::value;                                  // C++17
        -:  302:      template <class T> inline constexpr bool is_pod_v
        -:  303:        = is_pod<T>::value;                                              // C++17
        -:  304:      template <class T> inline constexpr bool is_literal_type_v
        -:  305:        = is_literal_type<T>::value;                                     // C++17; deprecated in C++17; removed in C++20
        -:  306:      template <class T> inline constexpr bool is_empty_v
        -:  307:        = is_empty<T>::value;                                            // C++17
        -:  308:      template <class T> inline constexpr bool is_polymorphic_v
        -:  309:        = is_polymorphic<T>::value;                                      // C++17
        -:  310:      template <class T> inline constexpr bool is_abstract_v
        -:  311:        = is_abstract<T>::value;                                         // C++17
        -:  312:      template <class T> inline constexpr bool is_final_v
        -:  313:        = is_final<T>::value;                                            // C++17
        -:  314:      template <class T> inline constexpr bool is_aggregate_v
        -:  315:        = is_aggregate<T>::value;                                        // C++17
        -:  316:      template <class T> inline constexpr bool is_signed_v
        -:  317:        = is_signed<T>::value;                                           // C++17
        -:  318:      template <class T> inline constexpr bool is_unsigned_v
        -:  319:        = is_unsigned<T>::value;                                         // C++17
        -:  320:      template <class T, class... Args> inline constexpr bool is_constructible_v
        -:  321:        = is_constructible<T, Args...>::value;                           // C++17
        -:  322:      template <class T> inline constexpr bool is_default_constructible_v
        -:  323:        = is_default_constructible<T>::value;                            // C++17
        -:  324:      template <class T> inline constexpr bool is_copy_constructible_v
        -:  325:        = is_copy_constructible<T>::value;                               // C++17
        -:  326:      template <class T> inline constexpr bool is_move_constructible_v
        -:  327:        = is_move_constructible<T>::value;                               // C++17
        -:  328:      template <class T, class U> inline constexpr bool is_assignable_v
        -:  329:        = is_assignable<T, U>::value;                                    // C++17
        -:  330:      template <class T> inline constexpr bool is_copy_assignable_v
        -:  331:        = is_copy_assignable<T>::value;                                  // C++17
        -:  332:      template <class T> inline constexpr bool is_move_assignable_v
        -:  333:        = is_move_assignable<T>::value;                                  // C++17
        -:  334:      template <class T, class U> inline constexpr bool is_swappable_with_v
        -:  335:        = is_swappable_with<T, U>::value;                                // C++17
        -:  336:      template <class T> inline constexpr bool is_swappable_v
        -:  337:        = is_swappable<T>::value;                                        // C++17
        -:  338:      template <class T> inline constexpr bool is_destructible_v
        -:  339:        = is_destructible<T>::value;                                     // C++17
        -:  340:      template <class T, class... Args> inline constexpr bool is_trivially_constructible_v
        -:  341:        = is_trivially_constructible<T, Args...>::value;                 // C++17
        -:  342:      template <class T> inline constexpr bool is_trivially_default_constructible_v
        -:  343:        = is_trivially_default_constructible<T>::value;                  // C++17
        -:  344:      template <class T> inline constexpr bool is_trivially_copy_constructible_v
        -:  345:        = is_trivially_copy_constructible<T>::value;                     // C++17
        -:  346:      template <class T> inline constexpr bool is_trivially_move_constructible_v
        -:  347:        = is_trivially_move_constructible<T>::value;                     // C++17
        -:  348:      template <class T, class U> inline constexpr bool is_trivially_assignable_v
        -:  349:        = is_trivially_assignable<T, U>::value;                          // C++17
        -:  350:      template <class T> inline constexpr bool is_trivially_copy_assignable_v
        -:  351:        = is_trivially_copy_assignable<T>::value;                        // C++17
        -:  352:      template <class T> inline constexpr bool is_trivially_move_assignable_v
        -:  353:        = is_trivially_move_assignable<T>::value;                        // C++17
        -:  354:      template <class T> inline constexpr bool is_trivially_destructible_v
        -:  355:        = is_trivially_destructible<T>::value;                           // C++17
        -:  356:      template <class T, class... Args> inline constexpr bool is_nothrow_constructible_v
        -:  357:        = is_nothrow_constructible<T, Args...>::value;                   // C++17
        -:  358:      template <class T> inline constexpr bool is_nothrow_default_constructible_v
        -:  359:        = is_nothrow_default_constructible<T>::value;                    // C++17
        -:  360:      template <class T> inline constexpr bool is_nothrow_copy_constructible_v
        -:  361:        = is_nothrow_copy_constructible<T>::value;                       // C++17
        -:  362:      template <class T> inline constexpr bool is_nothrow_move_constructible_v
        -:  363:        = is_nothrow_move_constructible<T>::value;                       // C++17
        -:  364:      template <class T, class U> inline constexpr bool is_nothrow_assignable_v
        -:  365:        = is_nothrow_assignable<T, U>::value;                            // C++17
        -:  366:      template <class T> inline constexpr bool is_nothrow_copy_assignable_v
        -:  367:        = is_nothrow_copy_assignable<T>::value;                          // C++17
        -:  368:      template <class T> inline constexpr bool is_nothrow_move_assignable_v
        -:  369:        = is_nothrow_move_assignable<T>::value;                          // C++17
        -:  370:      template <class T, class U> inline constexpr bool is_nothrow_swappable_with_v
        -:  371:        = is_nothrow_swappable_with<T, U>::value;                       // C++17
        -:  372:      template <class T> inline constexpr bool is_nothrow_swappable_v
        -:  373:        = is_nothrow_swappable<T>::value;                               // C++17
        -:  374:      template <class T> inline constexpr bool is_nothrow_destructible_v
        -:  375:        = is_nothrow_destructible<T>::value;                             // C++17
        -:  376:      template <class T> inline constexpr bool has_virtual_destructor_v
        -:  377:        = has_virtual_destructor<T>::value;                              // C++17
        -:  378:      template<class T> inline constexpr bool has_unique_object_representations_v // C++17
        -:  379:        = has_unique_object_representations<T>::value;
        -:  380:
        -:  381:      // See C++14 20.10.5, type property queries
        -:  382:      template <class T> inline constexpr size_t alignment_of_v
        -:  383:        = alignment_of<T>::value;                                        // C++17
        -:  384:      template <class T> inline constexpr size_t rank_v
        -:  385:        = rank<T>::value;                                                // C++17
        -:  386:      template <class T, unsigned I = 0> inline constexpr size_t extent_v
        -:  387:        = extent<T, I>::value;                                           // C++17
        -:  388:
        -:  389:      // See C++14 20.10.6, type relations
        -:  390:      template <class T, class U> inline constexpr bool is_same_v
        -:  391:        = is_same<T, U>::value;                                          // C++17
        -:  392:      template <class Base, class Derived> inline constexpr bool is_base_of_v
        -:  393:        = is_base_of<Base, Derived>::value;                              // C++17
        -:  394:      template <class From, class To> inline constexpr bool is_convertible_v
        -:  395:        = is_convertible<From, To>::value;                               // C++17
        -:  396:      template <class Fn, class... ArgTypes> inline constexpr bool is_invocable_v
        -:  397:        = is_invocable<Fn, ArgTypes...>::value;                          // C++17
        -:  398:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_invocable_r_v
        -:  399:        = is_invocable_r<R, Fn, ArgTypes...>::value;                     // C++17
        -:  400:      template <class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_v
        -:  401:        = is_nothrow_invocable<Fn, ArgTypes...>::value;                  // C++17
        -:  402:      template <class R, class Fn, class... ArgTypes> inline constexpr bool is_nothrow_invocable_r_v
        -:  403:        = is_nothrow_invocable_r<R, Fn, ArgTypes...>::value;             // C++17
        -:  404:
        -:  405:      // [meta.logical], logical operator traits:
        -:  406:      template<class... B> struct conjunction;                           // C++17
        -:  407:      template<class... B>
        -:  408:        inline constexpr bool conjunction_v = conjunction<B...>::value;  // C++17
        -:  409:      template<class... B> struct disjunction;                           // C++17
        -:  410:      template<class... B>
        -:  411:        inline constexpr bool disjunction_v = disjunction<B...>::value;  // C++17
        -:  412:      template<class B> struct negation;                                 // C++17
        -:  413:      template<class B>
        -:  414:        inline constexpr bool negation_v = negation<B>::value;           // C++17
        -:  415:
        -:  416:}
        -:  417:
        -:  418:*/
        -:  419:#include <__assert> // all public C++ headers provide the assertion handler
        -:  420:#include <__config>
        -:  421:#include <__functional/invoke.h>
        -:  422:#include <__type_traits/add_const.h>
        -:  423:#include <__type_traits/add_cv.h>
        -:  424:#include <__type_traits/add_lvalue_reference.h>
        -:  425:#include <__type_traits/add_pointer.h>
        -:  426:#include <__type_traits/add_rvalue_reference.h>
        -:  427:#include <__type_traits/add_volatile.h>
        -:  428:#include <__type_traits/aligned_storage.h>
        -:  429:#include <__type_traits/aligned_union.h>
        -:  430:#include <__type_traits/alignment_of.h>
        -:  431:#include <__type_traits/apply_cv.h>
        -:  432:#include <__type_traits/common_reference.h>
        -:  433:#include <__type_traits/common_type.h>
        -:  434:#include <__type_traits/conditional.h>
        -:  435:#include <__type_traits/conjunction.h>
        -:  436:#include <__type_traits/decay.h>
        -:  437:#include <__type_traits/disjunction.h>
        -:  438:#include <__type_traits/enable_if.h>
        -:  439:#include <__type_traits/extent.h>
        -:  440:#include <__type_traits/has_unique_object_representation.h>
        -:  441:#include <__type_traits/has_virtual_destructor.h>
        -:  442:#include <__type_traits/integral_constant.h>
        -:  443:#include <__type_traits/is_abstract.h>
        -:  444:#include <__type_traits/is_aggregate.h>
        -:  445:#include <__type_traits/is_arithmetic.h>
        -:  446:#include <__type_traits/is_array.h>
        -:  447:#include <__type_traits/is_assignable.h>
        -:  448:#include <__type_traits/is_base_of.h>
        -:  449:#include <__type_traits/is_bounded_array.h>
        -:  450:#include <__type_traits/is_callable.h>
        -:  451:#include <__type_traits/is_class.h>
        -:  452:#include <__type_traits/is_compound.h>
        -:  453:#include <__type_traits/is_const.h>
        -:  454:#include <__type_traits/is_constant_evaluated.h>
        -:  455:#include <__type_traits/is_constructible.h>
        -:  456:#include <__type_traits/is_convertible.h>
        -:  457:#include <__type_traits/is_copy_assignable.h>
        -:  458:#include <__type_traits/is_copy_constructible.h>
        -:  459:#include <__type_traits/is_default_constructible.h>
        -:  460:#include <__type_traits/is_destructible.h>
        -:  461:#include <__type_traits/is_empty.h>
        -:  462:#include <__type_traits/is_enum.h>
        -:  463:#include <__type_traits/is_final.h>
        -:  464:#include <__type_traits/is_floating_point.h>
        -:  465:#include <__type_traits/is_function.h>
        -:  466:#include <__type_traits/is_fundamental.h>
        -:  467:#include <__type_traits/is_integral.h>
        -:  468:#include <__type_traits/is_literal_type.h>
        -:  469:#include <__type_traits/is_member_function_pointer.h>
        -:  470:#include <__type_traits/is_member_object_pointer.h>
        -:  471:#include <__type_traits/is_member_pointer.h>
        -:  472:#include <__type_traits/is_move_assignable.h>
        -:  473:#include <__type_traits/is_move_constructible.h>
        -:  474:#include <__type_traits/is_nothrow_assignable.h>
        -:  475:#include <__type_traits/is_nothrow_constructible.h>
        -:  476:#include <__type_traits/is_nothrow_convertible.h>
        -:  477:#include <__type_traits/is_nothrow_copy_assignable.h>
        -:  478:#include <__type_traits/is_nothrow_copy_constructible.h>
        -:  479:#include <__type_traits/is_nothrow_default_constructible.h>
        -:  480:#include <__type_traits/is_nothrow_destructible.h>
        -:  481:#include <__type_traits/is_nothrow_move_assignable.h>
        -:  482:#include <__type_traits/is_nothrow_move_constructible.h>
        -:  483:#include <__type_traits/is_null_pointer.h>
        -:  484:#include <__type_traits/is_object.h>
        -:  485:#include <__type_traits/is_pod.h>
        -:  486:#include <__type_traits/is_pointer.h>
        -:  487:#include <__type_traits/is_polymorphic.h>
        -:  488:#include <__type_traits/is_reference.h>
        -:  489:#include <__type_traits/is_reference_wrapper.h>
        -:  490:#include <__type_traits/is_referenceable.h>
        -:  491:#include <__type_traits/is_same.h>
        -:  492:#include <__type_traits/is_scalar.h>
        -:  493:#include <__type_traits/is_scoped_enum.h>
        -:  494:#include <__type_traits/is_signed.h>
        -:  495:#include <__type_traits/is_standard_layout.h>
        -:  496:#include <__type_traits/is_trivial.h>
        -:  497:#include <__type_traits/is_trivially_assignable.h>
        -:  498:#include <__type_traits/is_trivially_constructible.h>
        -:  499:#include <__type_traits/is_trivially_copy_assignable.h>
        -:  500:#include <__type_traits/is_trivially_copy_constructible.h>
        -:  501:#include <__type_traits/is_trivially_copyable.h>
        -:  502:#include <__type_traits/is_trivially_default_constructible.h>
        -:  503:#include <__type_traits/is_trivially_destructible.h>
        -:  504:#include <__type_traits/is_trivially_move_assignable.h>
        -:  505:#include <__type_traits/is_trivially_move_constructible.h>
        -:  506:#include <__type_traits/is_unbounded_array.h>
        -:  507:#include <__type_traits/is_union.h>
        -:  508:#include <__type_traits/is_unsigned.h>
        -:  509:#include <__type_traits/is_void.h>
        -:  510:#include <__type_traits/is_volatile.h>
        -:  511:#include <__type_traits/make_signed.h>
        -:  512:#include <__type_traits/make_unsigned.h>
        -:  513:#include <__type_traits/negation.h>
        -:  514:#include <__type_traits/rank.h>
        -:  515:#include <__type_traits/remove_all_extents.h>
        -:  516:#include <__type_traits/remove_const.h>
        -:  517:#include <__type_traits/remove_cv.h>
        -:  518:#include <__type_traits/remove_extent.h>
        -:  519:#include <__type_traits/remove_pointer.h>
        -:  520:#include <__type_traits/remove_reference.h>
        -:  521:#include <__type_traits/remove_volatile.h>
        -:  522:#include <__type_traits/type_identity.h>
        -:  523:#include <__type_traits/underlying_type.h>
        -:  524:#include <__type_traits/void_t.h>
        -:  525:#include <__utility/declval.h>
        -:  526:#include <cstddef>
        -:  527:#include <cstdint>
        -:  528:#include <version>
        -:  529:
        -:  530:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  531:#  pragma GCC system_header
        -:  532:#endif
        -:  533:
        -:  534:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  535:
        -:  536:template <class _T1, class _T2> struct _LIBCPP_TEMPLATE_VIS pair;
        -:  537:template <class _Tp> struct _LIBCPP_TEMPLATE_VIS hash;
        -:  538:
        -:  539:// Member detector base
        -:  540:
        -:  541:template <class _Tp, bool>
        -:  542:struct _LIBCPP_TEMPLATE_VIS __dependent_type : public _Tp {};
        -:  543:
        -:  544:// is_integral
        -:  545:
        -:  546:template <class _Tp>
        -:  547:struct __unconstref {
        -:  548:    typedef _LIBCPP_NODEBUG typename remove_const<typename remove_reference<_Tp>::type>::type type;
        -:  549:};
        -:  550:
        -:  551:#ifndef _LIBCPP_CXX03_LANG
        -:  552:// First of all, we can't implement this check in C++03 mode because the {}
        -:  553:// default initialization syntax isn't valid.
        -:  554:// Second, we implement the trait in a funny manner with two defaulted template
        -:  555:// arguments to workaround Clang's PR43454.
        -:  556:template <class _Tp>
        -:  557:void __test_implicit_default_constructible(_Tp);
        -:  558:
        -:  559:template <class _Tp, class = void, class = typename is_default_constructible<_Tp>::type>
        -:  560:struct __is_implicitly_default_constructible
        -:  561:    : false_type
        -:  562:{ };
        -:  563:
        -:  564:template <class _Tp>
        -:  565:struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), true_type>
        -:  566:    : true_type
        -:  567:{ };
        -:  568:
        -:  569:template <class _Tp>
        -:  570:struct __is_implicitly_default_constructible<_Tp, decltype(__test_implicit_default_constructible<_Tp const&>({})), false_type>
        -:  571:    : false_type
        -:  572:{ };
        -:  573:#endif // !C++03
        -:  574:
        -:  575:// result_of
        -:  576:
        -:  577:#if _LIBCPP_STD_VER <= 17 || defined(_LIBCPP_ENABLE_CXX20_REMOVED_TYPE_TRAITS)
        -:  578:template <class _Callable> class _LIBCPP_DEPRECATED_IN_CXX17 result_of;
        -:  579:
        -:  580:template <class _Fp, class ..._Args>
        -:  581:class _LIBCPP_TEMPLATE_VIS result_of<_Fp(_Args...)>
        -:  582:    : public __invoke_of<_Fp, _Args...>
        -:  583:{
        -:  584:};
        -:  585:
        -:  586:#if _LIBCPP_STD_VER > 11
        -:  587:template <class _Tp> using result_of_t _LIBCPP_DEPRECATED_IN_CXX17 = typename result_of<_Tp>::type;
        -:  588:#endif // _LIBCPP_STD_VER > 11
        -:  589:#endif // _LIBCPP_STD_VER <= 17 || defined(_LIBCPP_ENABLE_CXX20_REMOVED_TYPE_TRAITS)
        -:  590:
        -:  591:// __swappable
        -:  592:
        -:  593:template <class _Tp> struct __is_swappable;
        -:  594:template <class _Tp> struct __is_nothrow_swappable;
        -:  595:
        -:  596:
        -:  597:#ifndef _LIBCPP_CXX03_LANG
        -:  598:template <class _Tp>
        -:  599:using __swap_result_t = typename enable_if<is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value>::type;
        -:  600:#else
        -:  601:template <class>
        -:  602:using __swap_result_t = void;
        -:  603:#endif
        -:  604:
        -:  605:template <class _Tp>
        -:  606:inline _LIBCPP_INLINE_VISIBILITY
        -:  607:_LIBCPP_CONSTEXPR_AFTER_CXX17 __swap_result_t<_Tp>
        -:  608:swap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&
        -:  609:                                    is_nothrow_move_assignable<_Tp>::value);
        -:  610:
        -:  611:template<class _Tp, size_t _Np>
        -:  612:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX17
        -:  613:typename enable_if<
        -:  614:    __is_swappable<_Tp>::value
        -:  615:>::type
        -:  616:swap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value);
        -:  617:
        -:  618:namespace __detail
        -:  619:{
        -:  620:// ALL generic swap overloads MUST already have a declaration available at this point.
        -:  621:
        -:  622:template <class _Tp, class _Up = _Tp,
        -:  623:          bool _NotVoid = !is_void<_Tp>::value && !is_void<_Up>::value>
        -:  624:struct __swappable_with
        -:  625:{
        -:  626:    template <class _LHS, class _RHS>
        -:  627:    static decltype(swap(declval<_LHS>(), declval<_RHS>()))
        -:  628:    __test_swap(int);
        -:  629:    template <class, class>
        -:  630:    static __nat __test_swap(long);
        -:  631:
        -:  632:    // Extra parens are needed for the C++03 definition of decltype.
        -:  633:    typedef decltype((__test_swap<_Tp, _Up>(0))) __swap1;
        -:  634:    typedef decltype((__test_swap<_Up, _Tp>(0))) __swap2;
        -:  635:
        -:  636:    static const bool value = _IsNotSame<__swap1, __nat>::value
        -:  637:                           && _IsNotSame<__swap2, __nat>::value;
        -:  638:};
        -:  639:
        -:  640:template <class _Tp, class _Up>
        -:  641:struct __swappable_with<_Tp, _Up,  false> : false_type {};
        -:  642:
        -:  643:template <class _Tp, class _Up = _Tp, bool _Swappable = __swappable_with<_Tp, _Up>::value>
        -:  644:struct __nothrow_swappable_with {
        -:  645:  static const bool value =
        -:  646:#ifndef _LIBCPP_HAS_NO_NOEXCEPT
        -:  647:      noexcept(swap(declval<_Tp>(), declval<_Up>()))
        -:  648:  &&  noexcept(swap(declval<_Up>(), declval<_Tp>()));
        -:  649:#else
        -:  650:      false;
        -:  651:#endif
        -:  652:};
        -:  653:
        -:  654:template <class _Tp, class _Up>
        -:  655:struct __nothrow_swappable_with<_Tp, _Up, false> : false_type {};
        -:  656:
        -:  657:} // namespace __detail
        -:  658:
        -:  659:template <class _Tp>
        -:  660:struct __is_swappable
        -:  661:    : public integral_constant<bool, __detail::__swappable_with<_Tp&>::value>
        -:  662:{
        -:  663:};
        -:  664:
        -:  665:template <class _Tp>
        -:  666:struct __is_nothrow_swappable
        -:  667:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp&>::value>
        -:  668:{
        -:  669:};
        -:  670:
        -:  671:#if _LIBCPP_STD_VER > 14
        -:  672:
        -:  673:template <class _Tp, class _Up>
        -:  674:struct _LIBCPP_TEMPLATE_VIS is_swappable_with
        -:  675:    : public integral_constant<bool, __detail::__swappable_with<_Tp, _Up>::value>
        -:  676:{
        -:  677:};
        -:  678:
        -:  679:template <class _Tp>
        -:  680:struct _LIBCPP_TEMPLATE_VIS is_swappable
        -:  681:    : public conditional<
        -:  682:        __is_referenceable<_Tp>::value,
        -:  683:        is_swappable_with<
        -:  684:            typename add_lvalue_reference<_Tp>::type,
        -:  685:            typename add_lvalue_reference<_Tp>::type>,
        -:  686:        false_type
        -:  687:    >::type
        -:  688:{
        -:  689:};
        -:  690:
        -:  691:template <class _Tp, class _Up>
        -:  692:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable_with
        -:  693:    : public integral_constant<bool, __detail::__nothrow_swappable_with<_Tp, _Up>::value>
        -:  694:{
        -:  695:};
        -:  696:
        -:  697:template <class _Tp>
        -:  698:struct _LIBCPP_TEMPLATE_VIS is_nothrow_swappable
        -:  699:    : public conditional<
        -:  700:        __is_referenceable<_Tp>::value,
        -:  701:        is_nothrow_swappable_with<
        -:  702:            typename add_lvalue_reference<_Tp>::type,
        -:  703:            typename add_lvalue_reference<_Tp>::type>,
        -:  704:        false_type
        -:  705:    >::type
        -:  706:{
        -:  707:};
        -:  708:
        -:  709:template <class _Tp, class _Up>
        -:  710:inline constexpr bool is_swappable_with_v = is_swappable_with<_Tp, _Up>::value;
        -:  711:
        -:  712:template <class _Tp>
        -:  713:inline constexpr bool is_swappable_v = is_swappable<_Tp>::value;
        -:  714:
        -:  715:template <class _Tp, class _Up>
        -:  716:inline constexpr bool is_nothrow_swappable_with_v = is_nothrow_swappable_with<_Tp, _Up>::value;
        -:  717:
        -:  718:template <class _Tp>
        -:  719:inline constexpr bool is_nothrow_swappable_v = is_nothrow_swappable<_Tp>::value;
        -:  720:
        -:  721:#endif // _LIBCPP_STD_VER > 14
        -:  722:
        -:  723:template <class _Tp, bool = is_enum<_Tp>::value>
        -:  724:struct __sfinae_underlying_type
        -:  725:{
        -:  726:    typedef typename underlying_type<_Tp>::type type;
        -:  727:    typedef decltype(((type)1) + 0) __promoted_type;
        -:  728:};
        -:  729:
        -:  730:template <class _Tp>
        -:  731:struct __sfinae_underlying_type<_Tp, false> {};
        -:  732:
        -:  733:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  734:int __convert_to_integral(int __val) { return __val; }
        -:  735:
        -:  736:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  737:unsigned __convert_to_integral(unsigned __val) { return __val; }
        -:  738:
        -:  739:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
function _ZNSt3__121__convert_to_integralB6v15006El called 6 returned 100% blocks executed 100%
        6:  740:long __convert_to_integral(long __val) { return __val; }
        6:  740-block  0
        -:  741:
        -:  742:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  743:unsigned long __convert_to_integral(unsigned long __val) { return __val; }
        -:  744:
        -:  745:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  746:long long __convert_to_integral(long long __val) { return __val; }
        -:  747:
        -:  748:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  749:unsigned long long __convert_to_integral(unsigned long long __val) {return __val; }
        -:  750:
        -:  751:template<typename _Fp>
        -:  752:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  753:typename enable_if<is_floating_point<_Fp>::value, long long>::type
        -:  754: __convert_to_integral(_Fp __val) { return __val; }
        -:  755:
        -:  756:#ifndef _LIBCPP_HAS_NO_INT128
        -:  757:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  758:__int128_t __convert_to_integral(__int128_t __val) { return __val; }
        -:  759:
        -:  760:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  761:__uint128_t __convert_to_integral(__uint128_t __val) { return __val; }
        -:  762:#endif
        -:  763:
        -:  764:template <class _Tp>
        -:  765:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  766:typename __sfinae_underlying_type<_Tp>::__promoted_type
        -:  767:__convert_to_integral(_Tp __val) { return __val; }
        -:  768:
        -:  769:// These traits are used in __tree and __hash_table
        -:  770:struct __extract_key_fail_tag {};
        -:  771:struct __extract_key_self_tag {};
        -:  772:struct __extract_key_first_tag {};
        -:  773:
        -:  774:template <class _ValTy, class _Key,
        -:  775:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -:  776:struct __can_extract_key
        -:  777:    : conditional<_IsSame<_RawValTy, _Key>::value, __extract_key_self_tag,
        -:  778:                  __extract_key_fail_tag>::type {};
        -:  779:
        -:  780:template <class _Pair, class _Key, class _First, class _Second>
        -:  781:struct __can_extract_key<_Pair, _Key, pair<_First, _Second> >
        -:  782:    : conditional<_IsSame<typename remove_const<_First>::type, _Key>::value,
        -:  783:                  __extract_key_first_tag, __extract_key_fail_tag>::type {};
        -:  784:
        -:  785:// __can_extract_map_key uses true_type/false_type instead of the tags.
        -:  786:// It returns true if _Key != _ContainerValueTy (the container is a map not a set)
        -:  787:// and _ValTy == _Key.
        -:  788:template <class _ValTy, class _Key, class _ContainerValueTy,
        -:  789:          class _RawValTy = typename __unconstref<_ValTy>::type>
        -:  790:struct __can_extract_map_key
        -:  791:    : integral_constant<bool, _IsSame<_RawValTy, _Key>::value> {};
        -:  792:
        -:  793:// This specialization returns __extract_key_fail_tag for non-map containers
        -:  794:// because _Key == _ContainerValueTy
        -:  795:template <class _ValTy, class _Key, class _RawValTy>
        -:  796:struct __can_extract_map_key<_ValTy, _Key, _Key, _RawValTy>
        -:  797:    : false_type {};
        -:  798:
        -:  799:template <class _CharT>
        -:  800:using _IsCharLikeType = _And<is_standard_layout<_CharT>, is_trivial<_CharT> >;
        -:  801:
        -:  802:template<class _Tp>
        -:  803:using __make_const_lvalue_ref = const typename remove_reference<_Tp>::type&;
        -:  804:
        -:  805:template<bool _Const, class _Tp>
        -:  806:using __maybe_const = typename conditional<_Const, const _Tp, _Tp>::type;
        -:  807:
        -:  808:_LIBCPP_END_NAMESPACE_STD
        -:  809:
        -:  810:#endif // _LIBCPP_TYPE_TRAITS
